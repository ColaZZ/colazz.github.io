[{"title":"Flask复习 十四 应用编程接口","date":"2017-04-03T16:33:42.000Z","path":"2017/04/04/Flask复习-十四-应用编程接口/","text":"Flask是开发REST架构Web服务的理想架构,因为Flask天生轻量. 14.1 REST简介14.1.1 资源就是一切 资源是REST架构方式的核心概念.在REST架构中,资源是程序中你要着重关注的事物.例如,在博客程序中,用户/博客文章和评论都是资源. 每个资源都要使用唯一的URL表示. 某一类资源的集合也要有一个URL. 14.1.2 请求方法 GET POST PUT DELETE DELETE 14.1.3 请求和响应主体REST Web服务常用的两种编码方式是JavaScript对象表示法(JSON)和可扩展标记语言(XML) 14.1.4 版本14.2 使用Flask提供REST Web服务14.2.1 创建API蓝本14.2.2 错误处理为所有客户端生成适当响应的一种方法是,在错误处理程序中根据客户端请求的格式改写响应,这种技术成为内容协商. 14.2.3 使用Flask-HTTPAuth认证用户 REST Web服务的特征之一是无状态,即服务器在两次请求之间不能”记住”客户端的任何消息.客户端必须在发出的请求中包含所有必要信息,因此所有请求都必须包含用户密令. 因为REST构架基于HTTP协议,所以发送密令的最佳方式是使用HTTP认证,基本认证和摘要认证都可以.在HTTP认证中,用户密令包含在请求的Authorization首部中. HTTP认证协议很简单,可以直接实现,不过Flask-HTTPAuth扩展提供了一个便利的包装,可以把协议的细节隐藏在修饰器之中,类似于Flask-login提供的login_required修饰器. 14.2.4 基于令牌的认证 使用基于令牌的认证方案时,客户端要先把登陆密令发送给一个特殊的URL,从而生成认证令牌.一旦客户端获得令牌,就可以用令牌代替登陆密令认证请求. 出于安全考虑,令牌有过期时间.令牌过期后,客户端必须重新发送登陆密令以生成新令牌.令牌落入他人之手所带来的安全隐患受限于令牌的短暂使用期限. generate_auth_toke()方法使用编码后的用户id字段值生成一个签名令牌,还指定了以秒为单位的过期时间. verify_auth_token()是静态方法,因为只有解码令牌后才能知道用户是谁. 为了能够认证包含令牌的请求,我们必须修改Flask-HTTPAuth提供的verify_password回调,除了普通的令牌之外,还要接受令牌. 14.2.5 资源和JSON的序列化转化 把文章转换成JSON格式的序列化字典:app/models def to_json(self): url,author,comments字段要分别返回各自资源的URL,因此他们使用url_for()生成,所调用的路由即将在API蓝本中定义. url_for()方法指定的参数_external=True,这么做是为了生成完整的URL,而不是生成传统WEB程序中经常使用的相对URL. 把用户转换成JSON格式的序列化字典 从JSON格式数据创建一篇博客文章 14.2.6 实现资源点现在我们需要实现用于处理不同资源的路由.GET请求往往是最简单的,因为它只返回信息,无需修改信息. 文章资源GET请求的处理程序:app/api_1_0/posts 用来防止未授权用户创建新博客文章的permission_required修饰器和程序中使用的类似,但会针对API蓝本进行自定义.:app/api_1_1/decorators 博客文章PUT请求的处理程序用来更新现有资源:app/api_1_0/post:edit_posts 14.2.7 分页大型资源集合和Web程序一样,Web服务也可以对集合进行分页. 分页文章资源:api/api_1_0/posts","tags":[]},{"title":"Flask复习 十三 用户评论","date":"2017-04-03T16:33:10.000Z","path":"2017/04/04/Flask复习-十三-用户评论/","text":"13.1 评论在数据库中的表示 评论属于某篇博客文章,因此定义了一个从posts表到commetns表的一对多关系.使用这个关系可以获取膜片特定博客文章的评论列表. comments表还和user表之间有一对多关系.通过这个关系可以获取用户发表的所有评论们还能间接知道用户发表了多少篇评论. Comments模型:app/models.Comment 几乎和Post模型一样,不过多了一个disabled字段.这是个布尔值字段,协管员通过这个字段查禁不当评论. 和博客文章一样,评论也定义了一个事件,在修改body字段时触发,自动把Markdown文本转换成HTML. 转换过程和博客文章一样,不过评论相对较短,而且对Markdown中允许使用的HTML标签要求更严格,要删除与段落相关的标签,只留下格式化字符的标签. 13.2 提交和显示评论 评论输入表单:app/main/forms body:StringField submit() 支持博客文章评论 13.3 管理评论 在导航栏中加入管理评论链接:base.html MODERATE_COMMENTS管理评论权限 管理评论的路由:app/main/views 从数据库中读取一页评论,将其传入模板进行渲染.除了评论列表之外,还把分页对象和当前页数传入了模板. 评论管理页面的模板:moderate.html","tags":[]},{"title":"Flask复习十二 关注者","date":"2017-04-03T16:32:36.000Z","path":"2017/04/04/Flask复习十二-关注者/","text":"12.1 再论数据库关系12.1.1 多对多关系多对多关系解决方法是添加第三张表,这个表称为关联表SQLAlchemy中,多对多关系仍使用定义一对多关系的db.relationship()方法进行定义,但在多对多关系中,必须把secondary参数设为关联表.多对多关系可以在任何一个类中定义,backref参数会处理好关系的另一侧.关联表就是一个简单的表,不是模型(model),SQLAlchemy会自动接管这个表. 12.1.2 自引用关系如果关系中的两侧都在同一个表中,这种关系称为自引用关系.本例的关联表是follows,其中每一行都表示一个用户关注了另一个用户. 12.1.3 高级多对多关系 关注关联表的模型实现:app/models:Follow follower_id followed_id timestamp 使用两个一对多关系实现的多对多关系 User followed followers 为了消除外键间的歧义,定义关系时必须使用可选参数foreign_keys指定的外键.而且db.backref()参数并不是指定这两个关系之间的引用关系,而是返回Follow模型. cascade参数的值是一组由逗号分隔的层叠选项. 关注关系的辅助方法:app/models 程序现在要吃力两个一对多关系,以便实现多对多关系.由于这些操作经常需要重复执行,所以最好在User模型中为所有可能的操作定义辅助方法. 关注def follow(self, user):手动把Follow实例插入关联表 取消关注def unfollow(self, user) 正在关注def is_following(self,user) 被关注def is_followed_by(self, user) 12.2 在资料页中显示关注者 在用户资料页上部添加关注信息:点击”关注”按钮后,执行的是/follow/ “关注”路由和视图函数:app/main/views 这个视图函数先加载请求的用户,确保用户存在且当前登录用户还没有关注这个用户,然后调用User模型中定义的辅助方法follow(),用以联接两个用户. /unfollow/路由的实现方法类似. “关注者”路由和试图函数:/followers/ 这个函数加载并验证请求的用户,然后使用第11章中介绍的技术分页显示该用户的followers关系.由于查询关注者返回的是Follow实例列表,为了渲染方便,我们将其转换成一个新列表,列表中的各元素都包含user和timestamp followers.html 模板使用两列表格实现,左边一列用于显示用户名和头像,右边一列用于显示Flask-Moment时间戳. 12.3 使用数据库联结查询所关注用户的文章left join 12Post.query.join(Follow, Follow.followed_id == Post.author_id)\\ .filter(Follow.follower_id == self.id) 12.4 在首页显示所关注用户的文章 显示所有博客文章或只显示所关注用户的文章 决定显示所有博客文章还是只显示所关注用户文章的选项存储在 cookie 的 show_followed 字段中,如果其值为非空字符串,则表示只显示所关注用户的文章. 查询所有文章还是所关注用户的文章 /all /followed 注册时把自己设为自己的关注者","tags":[]},{"title":"Flask复习 十一 博客文章(二)","date":"2017-04-03T16:31:45.000Z","path":"2017/04/04/Flask复习-十一-博客文章-二/","text":"11.3 分页显示长博客文章列表11.3.1 创建虚拟博客文章数据 使用ForgeryPy导入虚拟数据 dev.txt 列出开发过程中所需的依赖 prod.txt 列出生产中的所需的依赖 因此可以创建一个common.txt文件,在dev.txt和prod.txt中使用-r参数导入. 电子邮箱email=forgery_py.internet.email_address() 11.3.2 在页面中渲染数据 分业显示博客文章列表:app/main/views 渲染的页数从请求的查询字符串(request.args)中获取,如果没有明确指定,则默认渲染第一页. 为了显示某页中的记录,要把all()换成Flask-SQLAlchemy提供的paginate()方法.页数是paginate()方法的第一个参数,也是唯一必须的参数.可选参数per_page用来指定煤业现实的记录数量;如果没有指定,则默认显示20个记录.另一个可选参数为error_out,党旗设为True时(默认值), 如果请求的页数超出了范围,则会返回404错误;如果设为False,页数超出范围时会返回一个空列表. 11.3.3 添加分页导航//////// 11.4 使用markdown和falsk-pagedown支持富文本文章11.4.1 使用Flask-PageDown 初始化Flask-Pagedown:app/init.py 启用Markdown文章表单:用PageDownFieled替换TextAreaField 11.4.2 在服务器上处理富文本 在Post模型中处理Markdown文本:app/models/post 11.5 博客文章的固定链接/post/id为post表中的id 11.6 博客文章编辑器","tags":[]},{"title":"Flask复习 十一 博客文章(一)","date":"2017-04-03T16:30:56.000Z","path":"2017/04/04/Flask复习-十一-博客文章-一/","text":"11.1 提交和显示博客文章 文章模型:app/models id body:博客文章 timestamp:创建时间 author_id:作者id User中添加外键posts 博客文章表单:app/main/forms :PostForm body:博客内容 submit 处理博客文章的首页路由:app/main/views: / 把表单和完整的博客文章列表传给模板.文章列表按照时间戳进行降序排列. 博客文章表单采取惯常处理方式,如果提交的数据能通过验证就创建一个新Post实例. 在发布新文章之前,要检查当前用户是否有写文章的权限. 新文章对象的author属性值为表达式current_user._get_current_object().变量current_user由Flask-Login提供,和所有上下文变量一样,也是通过线程内的代理对象实现.这个对象类似用户对象,但实际上确是一个轻度包装,包含真正的用户对象.数据库需要真正的用户对象,因此要调用_get_current_object()方法. 显示博客文章的首页模板:app/templates/index.html 11.2 在资料页中显示博客文章 获取博客文章的资料页路由:app/main/views posts:user.posts关系获取 显示有博客文章的资料页模板 和index.html一样,user.html模板也要使用一个HTML元素渲染博客文章.维护两个完全相同的HTML片段副本可不是个好主意,遇到这种情况,Jinja2提供的include()指令就非常有用.","tags":[]},{"title":"Flask复习 十 用户资料","date":"2017-04-03T16:30:04.000Z","path":"2017/04/04/Flask复习-十-用户资料/","text":"10.1 资料信息 app/models 用户信息字段 name:真实姓名 location:所在地 about_me:自我介绍 member_since:注册日期 last_seen:最后访问日期 app/models 刷新用户最后访问时间 ping()方法,设置last_seen为datetime.utcnow() app/ayth/views 更新已登录用户的访问时间 before_app_request处理程序会在每次请求前运行 10.2 用户资料页面 资料页面的路由 app/main/views /user/ 10.3 资料编辑器10.3.1 用户级别的资料编辑器 资料编辑表单 app/main/forms : EditProfileForm name location about_me submit 资料编辑路由 app/main/views : enit_profiles() 把初始值赋值给form..data完成的 10.3.2 管理员级别的资料编辑器 管理员使用的资料编辑表单 app/main/forms EditProfileAdminForm email username confirmed role name location about_me submit 管理员的资料编辑路由 app/main/views /edit-profile/ 10.4 用户头像Gravatar提供的用户头像,生成头像的URL时,要计算电子邮件的MD5散列值.生成头像的URL是在http://www.gravatar.com/avatar/或https://secure.gravatar.com/avatar/之后加上这个MD5散列值. 生成Gravatar URL:app/models.User def gravatar() 使用缓存的MD5散列值生成Gravatar URL: app/models 添加字段avatar_hash ​","tags":[]},{"title":"Flask复习 九 用户角色","date":"2017-04-03T16:29:25.000Z","path":"2017/04/04/Flask复习-九-用户角色/","text":"9.1 角色在数据库中的表示 app/models default:只有一个角色的default字段要设为True,其他都设为False.注册时便分配. perimissions字段:整数,表示位标志. 程序的权限 操作 权限 说明 关注用户 0b00000001(0x01) 关注其他用户 在他人的文章中发表评论 0b00000010(0x02) 在他人撰写的文章中发布评论 写文章 0b00000100(0x04) 写原创文章 管理他人发表的评论 0b00001000(0x08) 查处他人发表的不当言论 管理员权限 0b10000000(0x80) 管理网站 class Permission 权限常量 insert_roles() 在数据库中创建角色用户User:FOLLOW | COMMENT | WRITE_ARTICLES0x01 | 0x02 | 0x04 = **0x07** 协管员Moderator:FOLLOW | COMMETN | WRITE_ARTICLES | MODERATE_COMMENTS0x01 | 0x02 | 0x04 | 0x08 = 0x0f 管理员Administrator:0xff如果以后更新了角色列表,就可以执行更新操作了. 9.2 赋予角色app/models: def init(self, **kwargs):User类的构造函数首先调用基类的构造函数,如果创建基类对象后还没定义角色,则根据email地址决定将其设为管理员还是默认角色. 9.3 角色验证 app/models: User:User模型中添加的can()方法在请求和赋予角色这两种权限之间进行位与操作.如果角色中包含请求的所有位权限位,则返回True,表示允许用户执行此项操作.检查管理员权限的功能经常用到,因此使用单独的方法is_administrator()实现. AnonymousUser:can()方法和is_administrator()方法.这个对象继承自Flask-Login中的AnonymousUserMixin类,并将其设为用户未登录时current_user的值.这样程序不用先检查用户是否登陆,就能自由调用current_user.can()和current_user.is_administrator() app/decorators:想让是凸函数只对具有特定权限的用户开放,可以使用自定义的修饰器. permission_required:检查常规权限 admin_required:检查管理员权限不具备条件时,返回403错误码.即HTTP禁止错误 app/main/init 把Permission类加入模板上下文 @main.app_context_processor:上下文处理器","tags":[]},{"title":"Flask复习 八 用户认证(三)","date":"2017-04-03T16:28:42.000Z","path":"2017/04/04/Flask复习-八-用户认证-三/","text":"8.5 注册新用户8.5.1 添加用户注册表单 app/auth/form 用户表单RegistrationForm email username:使用Regexp验证,确保username字段自包含字母,数字,下划线和点号.0,12&apos;Usernames must have only letters, &apos;&apos;numbers, dots or underscores&apos;) password:使用WTForms提供的EqualTo函数判断两次是否一致 password2: submit 查询email是否注册过: validate_email 查询用户名是否注册过: validate_username 使用wtf.quick_form(form)传入前端 最后在login页面加入注册链接 8.5.2 注册新用户 app/auth/view (‘/register’) email username password session.add flash(‘’) 重定向到登录 8.6 确认账户验证电子邮件中的确认地址 8.6.1 使用itsdangerous生成确认令牌TimedJSONWebSignatureSerializer类生成具有过期时间的JSON Web签名 generate_confirmation_token() 方法生成一个令牌，有效期默认为一小时.confirm() 方 法检验令牌，如果检验通过，则把新添加的 confirmed 属性设为 True. 除了检验令牌,confirm()方法还检查令牌中的id是否存储在current_user中的已登录用户匹配.如此一来,即使恶意用户知道如何生成签名令牌,也无法确认别人的账户. 8.6.2 发送确认邮件当前的/register路由把新用户添加到数据库中后,会重定向到/index.在重定向之前,这个路由需要发送确认邮件. app/auth/view /register app/auth/view /confirm/ login_required修饰器确保登陆后才能执行这个视图操作. 由于令牌确认完全在User模型中完成,所以视图函数只需调用confirm()方法即可,然后再根据确认结果显示不同的Flash消息.确认成功后,User模型中confirm属性的值会被修改并添加到会话中,请求处理完后,这个操作被提交到数据库. app/auth/views 在before_app_request处理程序中过滤未确认的账户同时满足以下三个条件,before_app_request处理程序会拦截请求. 用户已登录(current_user.is_authenticated()必须返回True) 用户的账户还未确认 请求的端点(使用reuqest.endpoint获取)不在认证蓝本中.访问认证路由要获取权限,因为这些路由的作用是让用户确认账户或执行其他账户管理操作. 8.7 管理账户8.7.1 修改密码 app/auth/forms ChangePasswordForm old_password:旧密码 password:新密码 password2:重输新密码 submit app/auth/views /change-password 改完密码add一次current_user 最后渲染auth/change_password.html app/templates/auth/change_password.html title col-md-4, wtf.quick_form(form) app/templates/base.html 修改登出部分 8.7.2 重设密码 app/auth/forms PasswordResetRequestForm email submit app/auth/forms PasswordRestForm email password password2 submit validate_email app/auth/views /reset password_reset_request() 渲染auth/reset_password.html app/auth/view /reset/ app/model generate_reset_token reset_password 8.7.3 修改电子邮件地址 app/auth/forms ChangeEmailForm email password submit validate_email app/auth/views /change-email @login_required:登录状态 def change_email_request","tags":[]},{"title":"Flask复习 八 用户认证(一)","date":"2017-04-03T16:27:59.000Z","path":"2017/04/04/Flask复习-八-用户认证-一/","text":"8.1 Flask的认证扩展使用的包如下: Flask-Login:管理已登录用户的用户会话 Werkzeug:计算密码散列值并进行核对 itsdangerous:生成并核对加密安全令牌 8.2 密码安全性若想保证数据库中用户密码的安全,关键在于不能存储密码本身,而要存储密码的散列值.接受密码为输入,使用一种或多种加密算法转换密码,最终得到一个和原始密码没有关系的字符序列. 使用werkzeug实现密码散列Werkzeug中的security模块实现散列值计算.两个函数: generate_password_hash(password, method=pdkfdf2:sha1, salt_length=8) 原始密码作为输入,返回一个字符串形式的散列值,散列值可保存在数据库中.method和salt_length的默认值就能满足大多数需求. check_password_hash(hash,password): 从数据库中取回密码散列值胡密码,True表明密码正确. 8.3 创建认证蓝本auth蓝本保存在同名Python包中,蓝本的包构造文件创建蓝本对象,再从views.py模块中引入路由. 同时,auth蓝本要在create_app()工厂函数中附加到程序上.url_prefix是可选参数.如果使用了这个参数,注册后蓝本中定义的所有路由都会加上指定的前缀.","tags":[]},{"title":"Flask复习 八 用户认证(二)","date":"2017-04-03T16:20:18.000Z","path":"2017/04/04/Flask复习-八-用户认证-二/","text":"8.4 使用Flask-Login认证用户8.4.1 准备用于登陆的用户模型 model:要使用Flask-Login,User Model必须实现几个方法.可以直接写出来,但是Flask-Login提供了一个UserMixin类,包含这几个方法的默认实现,且能满足大多数需求. 工厂函数初始化: LoginManager对象的session_protection属性可以设为None,’basic’,’strong’,已提供不同的安全等级防止用户会话遭篡改.设为’strong’时,Flask-Login会记录客户端IP的地址和浏览器的用户代理信息,如果发现异动就登出用户. login_view属性设置登录页面的端点. 最后实现一个回调函数,使用指定的标识符加载用户. 该回调函数接收以Unicode字符串形式表示的用户标识符.如果能找到用户,这个函数必须返回用户对象;否则应该返回None. 8.4.2 保护路由为了保护路由只让认证用户访问,Flask-Login提供了一个login_required修饰器. 8.4.3 添加登录表单给用户一个登录表单,一个用于输入电子邮件地址的文本字段,一个密码字段,一个”记住我”复选框和提交按钮. app/auth/forms email:验证函数Email() password:PasswordField表示type=’password’的元素 remember_me:BooleanField表示复选框 app/templates/base.html登录条 is_authenticated():判断用户是否登录,登录返回True,否则False 逻辑为如果用户在登录状态,则显示登出.否则显示登录. 8.4.4 登入用户 app/auth/views 这个视图函数创建了一个LoginForm.GET时视图函数直接渲染模板,即显示表单.POST时,Flask-WTF中的validate_on_submit()函数会验证表单数据,然后尝试登入用户. 首先使用填写的email从数据库中查询用户,然后verify_password(),第三步调用login_user()函数,在用户会话中把用户标记为已登录. 记住我选项:False的话,关闭浏览器后用户会话过期.True的话会在用户浏览器中写入一个长期有效的 cookie，使用这个 cookie 可以复现用户会话. 目标URL有两种可能:用户访问未授权的URL时会显示登录表单,Flask-Login会把原地址保存在查询字符串next中,从request.args中读取.如果没有next,则重定向到首页. 密码或email不正确,显示flash消息. 8.4.5 登出用户‘/logout’:使用logout_user()函数,实现删除并删除重设用户会话.随后显示一个Flash消息,再重定向到首页. 8.4.6 测试登录","tags":[]},{"title":"Flask复习 七 大型程序的结构(二)","date":"2017-04-03T16:19:31.000Z","path":"2017/04/04/Flask复习-七-大型程序的结构-二/","text":"7.4 启动脚本manage.pyw文件 初始化Flask-Script,Flask-Migrate和未Python Shell定义的上下文. 7.5 需求文件requirements.txt文件$ pip freeze >requirements.txt ```该命令自动生成这个文件123456789# 7.6 单元测试使用python标准库中的unittest编写(assertFasle和assertTrue)setUp() 方法尝试创建一个测试环境，类似于运行中的程序。首先，使用测试配置创建程 序，然后激活上下文。这一步的作用是确保能在测试中使用 current_app，像普通请求一 样。然后创建一个全新的数据库，以备不时之需。数据库和程序上下文在 tearDown() 方法 中删除。# 7.7 创建数据库数据库创建或者升级 (venv) $ python manage.py db upgrade```","tags":[]},{"title":"Flask复习 七 大型程序的结构(一)","date":"2017-04-03T16:19:03.000Z","path":"2017/04/04/Flask复习-七-大型程序的结构-一/","text":"7.1 项目结构1234567891011121314151617181920|-flasky |-app/ # Flask主程序 (7.3) |-templates/ |-static/ |-main/ |-__init__.py |-errors.py |-forms.py |-views.py |-__init__.py |-email.py |-models.py |-migrations/ # 数据库迁移脚本 |-tests/ # 单元测试 |-__init__.py |-test*.py |-venv/ # 虚拟环境 |-requirements.txt # 列出所有依赖包 |-config.py # 存储配置 (7.2) |-manage.py # 用于启动程序以及其他程序的任务 7.2 配置选项config.py文件 通过访问os.envirom字典可以访问环境变量 开发(dev), 测试(test), 生产环境(product)要使用不同的数据库,这样不会彼此影响.在config.py中,使用三个子类,SQLALCHEMY_DATABASE_URI变量都被指向了不同的值.这样程序就可以在不同的配置环境中运行,每个环境都使用不同的数据库. 7.3 程序包app文件夹 当然,如果你有需求,也可以使用其他名字 7.3.1 使用程序工厂函数app/init.py文件 单个文件开发程序很方便,但是有个很大的问题.程序在全局域中创建,所以无法动态修改配置.解决方法:延迟创建程序实例,把创建过程移到可显式调用的工厂函数中. 7.3.2 在蓝本中实现程序功能app/main/init.py文件 如果在app/init.py中create_app()之后再调用app.route修饰器显然太晚了.app.errorhandler也面临同样的问题. 幸好Flask使用蓝本提供了解决方法.蓝本和程序类似,也可以定义路由.不同的是,在蓝本中定义的路由处于休眠状态,直到蓝本注册到程序上之后,路由才真正的成为程序的一部分. 通过实例化一个Blueprint类对象可以创建蓝本.这个构造函数有两个必须制定的参数:蓝本的名字(main)和蓝本所在的包或模块(大多数情况下使用name变量即可). app/main/errors.py:蓝本中的错误处理在蓝本中编写错误处理程序稍有不同，如果使用 errorhandler 修饰器，那么只有蓝本中的错误才能触发处理程序。要想注册程序全局的错误处理程序，必须使用 app_errorhandler。 app/main/view.py:蓝本中定义的程序路由在蓝本中编写视图函数主要有两点不同:第一,和errorhandler一样,route路由修饰器由蓝本提供第二,url_for()函数的用法不同. url_for()函数的第一个参数是路由的端点名,在程序的路由中,默认为视图函数的名字. 在蓝本中,Flask会为蓝本中的全部端点加上一个命名空间,这样就可以在不同的蓝本中使用相同的端点名定义视图函数,而不会产生冲突.命名空间就是蓝本的名字(Blueprint构造函数的第一个参数),所以index()注册的端点名是main.index,其URL使用url_for(‘main.index’)获取. url_for()函数还支持一种简写的端点形式,在蓝本中可以省略蓝本名,例如url_for(&#39;.index&#39;),但是跨蓝本的重定向必须使用带有命名空间的端点名.","tags":[]},{"title":"Flask复习 六 电子邮件","date":"2017-04-03T16:18:28.000Z","path":"2017/04/04/Flask复习-六-电子邮件/","text":"使用Flask-Mail提供电子邮件支持Flask-Mail 连接到简单邮件传输协议（ Simple Mail Transfer Protocol， SMTP）服务器，并把邮件交给这个服务器发送。 如果不进行配置，Flask-Mail会连接localhost 上的端口 25，无需验证即可发送电子邮件。 Flask-Mail SMTP服务器的配置 配置 默认值 说明 MAIL_SERVER localhost 电子邮件服务器的主机名或IP地址 MAIL_PORT 25 电子邮件服务器的端口 MAIL_USE_TLS False 启用传输层安全协议(TLS) MAIL_USE_SSL False 启用安全套接层协议(SSL) MAIL_USERNAME None 邮件账户的用户名 MAIL_PASSWORD None 邮件账户的密码 示例:使用Gmail发送电子邮件1234567import os# ...app.config[&apos;MAIL_SERVER&apos;] = &apos;smtp.googlemail.com&apos;app.config[&apos;MAIL_PORT&apos;] = 587app.config[&apos;MAIL_USE_TLS&apos;] = Trueapp.config[&apos;MAIL_USERNAME&apos;] = os.environ.get(&apos;MAIL_USERNAME&apos;)app.config[&apos;MAIL_PASSWORD&apos;] = os.environ.get(&apos;MAIL_PASSWORD&apos;) 保存电子邮件服务器用户名和密码的两个环境变量要在环境中定义:12(venv) $ export MAIL_USERNAME=&lt;Gmail username&gt;(venv) $ export MAIL_PASSWORD=&lt;Gmail password&gt; 在程序中集成发送电子邮件功能异步发送电子邮件","tags":[]},{"title":"Flask复习 五 数据库(三)","date":"2017-04-03T16:17:25.000Z","path":"2017/04/04/Flask复习-五-数据库-三/","text":"5.9 在视图函数中操作数据库5.10 集成python shell注册一个make_context回调函数,把对象添加到导入列表中1234from flask.ext.script import Shelldef make_shell_context(): return dict(app=app, db=db, User=User, Role=Role)manager.add_command(&quot;shell&quot;,Shell(make_context=make_shell_context)) 5.11 使用Flask-Migrate实现数据库迁移Flask-Migrate扩展对Alembic做了轻量级包装,病集成到Flask-Script中,所有操作都通过Flask-Script完成. 5.11.1 创建迁移仓库首先,配置Flask-Migrate,把Flask-Migrate包装进Flask-Script语句中.1234from flask.ext.migrate import Migrate, MigrateCommand# ...migrate = Migrate(app, db)manager.add_command(&apos;db&apos;, MigrateCommand) 然后,使用init子命令创建迁移仓库:1(venv) $ python hello.py db init 这个命令会创建migrations文件夹,所有迁移脚本都存放其中. 5.11.2 创建迁移脚本在Alembic中,数据库迁移用迁移脚本表示.脚本中有两个函数,分别是upgrade()和downgrade().upgrade()函数把迁移中的改动应用到数据库中,downgrade()函数则将改动删除.migrade子命令用来自动创建迁移脚本:1(venv) $ python hello.py db migrate -m &quot;initial migration&quot; 5.11.3 更新数据库检查并修正好脚本之后,我们可以使用db upgrade命令把迁移应用到数据库中:1(venv) $ python hello.py db upgrade 对第一个迁移来说，其作用和调用 db.create_all() 方法一样。但在后续的迁移中，upgrade 命令能把改动应用到数据库中，且不影响其中保存的数据。","tags":[]},{"title":"Flask复习 五 数据库(二)","date":"2017-04-03T16:14:43.000Z","path":"2017/04/04/Flask复习-五-数据库-二/","text":"5.8 数据库操作5.8.1 创建表db.create_all()函数创建表123(venv) $ python hello.py shell&gt;&gt;&gt; from hello import db&gt;&gt;&gt; db.create_all() 删除旧表使用函数123456&lt;!-- more --&gt;## 5.8.2 插入行在Flask-SQLAlchemy中,会话由db.session表示.准备把对象写入数据库之前,先要将其添加到会话中: db.session.add(admin_role)db.session.add(mod_role)db.session.add(user_role)db.session.add(user_john)db.session.add(user_susan)db.session.add(user_david)1或者简写成: db.session.add_all([admin_role, mod_role, user_role,… user_john, user_susan, user_david])1然后调用commit()方法提交会话: db.session.commit()12345## 5.8.3 修改行调用add()方法也能更新模型## 5.8.4 删除行 db.session.delete(mod_role)db.session.commit()1234## 5.8.5 查询行Flask-SQLAlchemy为每个模型类都提供了query对象.所有记录: Role.query.all()User.query.all()12filter()过滤器可以配置query对象进行精确地数据库查询.若要查看SQLAlchemy为查询生成的原生SQL查询语句,只需把query对象转换成字符串: str(User.query.filter_by(role=user_role)) ‘SELECT users.id AS users_id, users.username AS users_username,users.role_id AS users_role_id FROM users WHERE :param_1 = users.role_id’``` 常用的SQLAlchemy查询过滤器 过滤器 说明 filter() 把过滤器添加到原查询上，返回一个新查询 filter_by() 把等值过滤器添加到原查询上，返回一个新查询 limit() 使用指定的值限制原查询返回的结果数量，返回一个新查询 offset() 偏移原查询返回的结果，返回一个新查询 order_by() 根据指定条件对原查询结果进行排序，返回一个新查询 group_by() 根据指定条件对原查询结果进行排序,返回一个新查询 常用的SQLAlchemy查询执行函数 方法 说明 all() 以列表形式返回查询的所有结果 first() 返回查询的第一个结果，如果没有结果，则返回 None first_or_404() 返回查询的第一个结果，如果没有结果，则终止请求,返回404错误响应 get() 返回指定主键对应的行，如果没有对应的行，则返回 None get_or_404() 返回指定主键对应的行，如果没有对应的行，则终止请求,返回404错误响应 count() 返回查询结果的数量 paginate() 返回一个Paginate对象,它包含指定范围内的结果","tags":[]},{"title":"Flask复习 五 数据库","date":"2017-04-03T16:13:57.000Z","path":"2017/04/04/Flask复习-五-数据库/","text":"SQL数据库:关系型数据库NoSQL数据库:文档数据库和键值对数据库 5.1 SQL数据库 5.2 NoSQL数据库 5.3 使用SQL还是NoSQLSQL 数据库擅于用高效且紧凑的形式存储结构化数据.这种数据库需要花费大量精力保证数据的一致性.NoSQL数据库放宽了对这种一致性的要求,从而获得性能上的优势. 5.4 Python数据库框架本项目选用Flask-SQLAlchemy 5.5 使用Flask-SQLAlchemy管理数据库数据库使用URL指定.程序使用的数据库URL必须保存到Flask配置对象的SQLALCHEMY_DATABASE_URI键中.配置对象中还有一个很有用的选项,即SQLALCHEMY_COMMIT_ON_TEARDOWN键,将其设为True时,每次请求结束后都会自动提交数据库中的变动. 配置SQLite数据库示例12345678910from flask.ext.sqlalchemy import SQLAlchemybasedir = os.path.abspath(os.path.dirname(__file__))app = Flask(__name__)app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] =\\ &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)app.config[&apos;SQLALCHEMY_COMMIT_ON_TEARDOWN&apos;] = Truedb = SQLAlchemy(app) db对象时SQLAlchemy类的实例,表示程序使用的数据库,同时还获得了Flask-SQLAlchemy提供的所有功能. 5.6 定义模型定义Role和User 123456789101112131415class Role(db.Model): __tablename__ = &apos;roles&apos; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) def __repr__(self): return &apos;&lt;Role %r&gt;&apos; % self.name class User(db.Model): __table__=&apos;roles&apos; id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) def __repr__(self): return &apos;&lt;User %r&gt;&apos; % self.username 定义数据库中使用的表名.1234567891011121314151617181920212223242526272829303132333435db.Column类构造的第一个参数是数据库列和模型属性的类型.常用的SQLAlchemy列类型| 类型名 | python类型 | 说明 || ------------ | ------------------ | ----------------------------- || Integer | int | 普通整数,一般是32位 || SmallInteger | int | 取值范围小的整数,一般是16位 || BigInteger | int或long | 不限精度的整数 || Float | float | 浮点数 || Numeric | decimal.Decimal | 定点数 || String | str | 变长字符串 || Text | str | 变长字符串,对较长或不限长度的字符串做了优化 || Unicode | unicode | 变长Unicode字符串 || UnicodeText | unicode | 变长Unicode字符串,对较长或不限长度的字符串做了优化 || Boolean | bool | 布尔值 || Date | datetime.date | 日期 || Time | datetime.date | 时间 || DateTime | datetime.datetime | 日期和时间 || Interval | datetime.timedelta | 时间间隔 || Enum | str | 一组字符串 || PickleType | 任何Python对象 | 自动使用Pickle序列化 || LargeBinary | str | 二进制文件 |最常使用的SQLAlchemy列选项| 选项名 | 说明 || ----------- | ------------------------------------- || primary_key | 如果设为True,这列就是表的主键 || unique | 如果设为True,这列不允许出现重复的值 || index | 如果设为True,为这列创建索引,提升查询效率 || nullable | 如果设为True,这列允许使用空值,如果设为False,这列不允许使用空值 || default | 为这列定义默认值 |# 5.7 关系 class Role(db.Model): # ... users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;) class User(db.Model): # ... role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;)) ```db.relationship() 的第一个参数表明这个关系的另一端是哪个模型.如果模型尚未定义,可使用字符串形式指定. db.relationship() 中的backref参数向User模型中添加一个role 的属性,从而定义反向关系.这一属性克替代role_id访问Role模型,此时获取的是模型对象,而不是外键的值. 常用的SQLAlchemy关系选项 选项名 说明 backref 在关系的另一个模型中添加反向引用 primaryjoin 明确指定两个模型之间使用的联结条件.只在模棱两可的关系中需要指定 lazy 指定如何加载相关记录。可选值有 select（首次访问时按需加载）、 immediate（源对象加 载后就加载）、 joined（加载记录，但使用联结）、 subquery（立即加载，但使用子查询），noload（永不加载）和 dynamic（不加载记录，但提供加载记录的查询）uselist | 如果设为False,不适用列表,而使用标量值order_by | 指定关系中记录的排序方式secondary | 指定多对多关系中关系表的名字secondaryjoin | SQLAlchemy无法自行决定时,指定多对多关系中的二级联结条件","tags":[]},{"title":"Flask复习 三 模板(三)","date":"2017-04-03T16:11:32.000Z","path":"2017/04/04/Flask复习-四-Web表单/","text":"使用Flask-WTF库实现Web表单 4.1 跨站请求伪造保护Flask-WTF保护方法:设置秘钥 12app = Flask(__name__)app.config[&apos;SECRET_KEY&apos;] = &apos;hard to guess string&apos; 4.2 表单类1234567from falsk.ext.wtf import Formfrom wtfforms import StringField, SubmitFieldfrom wtfforms.validators import Requiredclass NameForm(Form): name = StringField(&apos;what is your name?&apos;, validators=[Required()]) submit = SubmitField(&apos;Submit&apos;) StringField 类表示属性为 type=”text” 的 元素。SubmitField 类表示属性为 type=”submit” 的 元素。字段构造函数的第一个参数是把表单渲染成 HTML 时使用的标号。StringField 构造函数中的可选参数 validators 指定一个由验证函数组成的列表，在接受 用户提交的数据之前验证数据。验证函数 Required() 确保提交的字段不为空。 WTForms支持的HTML标准字段 字段类型 说明 StringField 文本字段 TextAreaField 多行文本字段 PasswordField 密码文本字段 HiddenField 隐藏文本字段 DateField 文本字段,值为datetime.date格式 DateTimeField 文本字段,值为datetime.datime格式 IntegerField 文本字段,值为整数 DecimalField 文本字段,值为decimal.Decimal FloatField 文本字段，值为浮点数 BooleanField 复选框,值为True和False RadioField 一组单选框 SelectField 下拉列表 SelectMultipleField 下拉列表,可以选择多个值 FileField 文件上传字段 SubmitField 表单提交按钮 FormField 把表单作为字段嵌入另一个表单 FieldList 一组制定类型的字段 WTForms验证函数 验证函数 说明 Email 验证电子邮件地址 EqualTo 比较两个字段的值;常用于要求输入两次密码进行确认的情况 IPAddress 验证 IPv4 网络地址 Length 验证输入字符串的长度 NumberRange Optional 验证输入的值在数字范围内 Optional 无输入值时跳过其他验证函数 Required 确保字段中有数据 Regexp 使用正则表达式验证输入值 URL 验证 URL AnyOf 确保输入值在可选值列表中 NoneOf 确保输入值不在可选值列表中 4.3 把表单渲染成HTMLFlask-Bootstrap 提供了一个非常高端的辅助函数，可以使用Bootstrap中预先定样式渲染整个 Flask-WTF 表单，而这些操作 只需一次调用即可完成。12&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125; &#123;&#123; wtf.quick_form(form) &#125;&#125; wtf.quick_form()函数的参数为Flask-WTF表单对象,使用Bootstrap的默认样式传入的表单. 4.4 在视图函数中处理表单表单大多作为POST请求进行处理(GET会在URL中暴露数据)12345678@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = &apos;&apos; return render_template(&apos;index.html&apos;, form=form, name=name) 局部变量 name 用来存放表单中输入的有效名字，如果没有输入，其值为 None。如上述代 码所示，在视图函数中创建一个 NameForm 类实例用于表示表单。提交表单后，如果数据能 被所有验证函数接受，那么 validate_on_submit() 方法的返回值为 True，否则返回 False。 这个函数的返回值决定是重新渲染表单还是处理表单提交的数据。 用户第一次访问程序时，服务器会收到一个没有表单数据的 GET 请求，所以 validateon submit() 将返回 False。if 语句的内容将被跳过，通过渲染模板处理请求，并传入表单对 象和值为 None 的 name 变量作为参数。用户会看到浏览器中显示了一个表单。 用户提交表单后，服务器收到一个包含数据的 POST 请求。validate_on_submit() 会调用 name 字段上附属的 Required() 验证函数。如果名字不为空，就能通过验证，validateon submit() 返回 True。现在，用户输入的名字可通过字段的 data 属性获取。在 if 语句中， 把名字赋值给局部变量 name，然后再把 data 属性设为空字符串，从而清空表单字段。最 后一行调用 render_template() 函数渲染模板，但这一次参数 name 的值为表单中输入的名 字，因此会显示一个针对该用户的欢迎消息。 4.5 重定向和用户会话用户输入名字后提交表单，然后点击浏览器的刷 新按钮，会看到一个莫名其妙的警告，要求在再次提交表单之前进行确认。之所以出现这 种情况，是因为刷新页面时浏览器会重新发送之前已经发送过的最后一个请求。如果这个 请求是一个包含表单数据的 POST 请求，刷新页面后会再次提交表单。大多数情况下，这并 不是理想的处理方式。 很多用户都不理解浏览器发出的这个警告。基于这个原因，最好别让 Web 程序把 POST 请 求作为浏览器发送的最后一个请求。 解决方法是,使用重定向作为POST请求的响应,而不是使用常规响应.浏览器收到 这种响应时，会向重定向的 URL 发起 GET 请求，显示页面的内容. 这个技巧称为Post/重定向/Get模式.12345678from flask import Flask, render_template, session, redirect, url_for@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data return redirect(url_for(&apos;index&apos;)) return render_template(&apos;index.html&apos;, form=form,name=session.get(&apos;name&apos;)) 4.6 Flash消息请求完成后,需要让用户知道确认消息,警告或者错误提醒.这个时候需要flash()函数,也是Flask的核心特性.1234567891011from flask import Flask, render_template, session, redirect, url_for, flash@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get(&apos;name&apos;) if old_name is not None and old_name != form.name.data: flash(&apos;Looks like you have changed your name!&apos;) session[&apos;name&apos;] = form.name.data return redirect(url_for(&apos;index&apos;)) return render_template(&apos;index.html&apos;, form = form, name = session.get(&apos;name&apos;)) 模板中渲染flash()消息,需要Flask开放的get_flashed_messages()函数.1234#...&#123;% for message in get_flashed_messages() %&#125;#...&#123;&#123; message &#125;&#125; 在模板中使用循环是因为在之前的请求循环中每次调用 flash() 函数时都会生成一个消息， 所以可能有多个消息在排队等待显示。get_flashed_messages() 函数获取的消息在下次调 用时不会再次返回，因此 Flash 消息只显示一次，然后就消失了。","tags":[]},{"title":"Flask复习 三 模板(二)","date":"2017-04-03T16:11:08.000Z","path":"2017/04/04/Flask复习-三-模板-二/","text":"3.2 使用Flask-Bootstrap集成 Bootstrap安装:$ pip install flask-bootstrap ```123初始化:&lt;!-- more --&gt; from flask.ext.bootstrap import Bootstrap #…bootstrap = Bootstrap(app)12345678910111213141516171819202122| 块名 | 说明 || ------------ | ----------------- || doc | 整个HTML文档 || html_attribs | &lt;html&gt;标签的属性 || html | &lt;html&gt;标签中的内容 || head | &lt;head&gt;标签中的内容 || title | &lt;title&gt;标签中的内容 || metas | 一组&lt;meta&gt;标签 || styles | 层叠样式表定义 || body_attribs | &lt;body&gt;标签的属性 || body | &lt;body&gt;标签中的内容 || navbar | 用户定义的导航条 || content | 用户定义的页面内容 || scripts | 文档底部的Javascript声明 |上表中很多块欧式Flask-Bootstrap自用的,如果直接重定义可能会导致一些问题.例如，Bootstrap所需的文件在styles和scripts块中声明。如果程序需要向已经有内容的块中添加新内容， 必须使用 Jinja2 提供的 super() 函数。# 3.3 自定义错误页面自定义错误页面的路由和响应函数:1. 404,客户端请求未知页面或路由时显示.2. 500,有未处理的异常时显示. @app.errorhandler(404):def page_not_found(e): return render_template(‘404.html’), 404 @app.errorhandler(500);def internal_server_error(e): return render_template(‘500.html’), 500123456错误页面的模板由Jinja2的模板继承机制实现.# 3.4 链接```url_for()``` 辅助函数,她可以使用程序URL映射中保存的信息生成URL.以下都是合法调用: url_for(‘index’) # 得到的结果是/url_for(‘index’, _external=True) # 得到的结果是绝对地址,http://localhost:5000/url_for(‘user’, name=’john’, _external=True) #返回结果是http://localhsot:5000/user/johnurl_for(‘index’, page=2) #得到的结果是/?page=2``` 3.5 静态文件static文件夹下面 3.6使用Flask-Moment本地化日期和时间要想在服务器上只是用UTC时间,一个优雅的解决方案是,把时间单位发送给Web浏览器,转换成当地时间,然后渲染.本项目中使用第三方库Flask-Moment,把moment.js集成到Jinja2模板中.","tags":[]},{"title":"Flask复习 二 程序基本结构","date":"2017-04-03T16:03:38.000Z","path":"2017/04/04/Flask复习-二-程序基本结构/","text":"2.1 初始化Web服务器使用一种名为Web服务器网关接口的协议,把接受自客户端的所有请求都转交给这个对象处理. 12from flask import Flaskapp = Flask(__name__) name的值app就是程序主模块或包的名字. 2.2 路由和视图函数app.route修饰器定义路由 123@app.route(&apos;/&apos;)def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos; index为视图函数,在浏览器中访问默认网址后,会触发服务器执行index()函数.这个函数的返回值成为响应,是客户端接收到的内容.动态地址route修饰器同样支持. 123@app.route(&apos;/user/&lt;name&gt;&apos;)def user(name): return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name 尖括号中123# 2.3 启动服务器```run``` 方法启动Flask集成的开发Web环境: if name == ‘main‘ app.run(debug=True)1234567891011121314151617181920212223242526272829303132333435363738服务器启动后,胡进入轮询,等待并处理请求.轮询会一直运行,知道程序停止,比如ctrl-c.# 2.5 请求-响应循环## 2.5.1 程序和请求上下文上下文把某些对象变为全局可访问.有了上下文,可以避免大量可有可无的参数把视图函数搞乱.Flask使用上下文让特定的变量在一个线程中全局可访问,并且不会干扰其他线程.| 变量名 | 上下文 | 说明 || ----------- | ----- | --------------------------- || current_app | 程序上下文 | 当前激活程序的程序实例 || g | 程序上下文 | 处理请求时用作临时存储的对象.每次请求都会重设这个变量 || request | 请求上下文 | 请求对象,封装了客户端发出的HTTP中的请求 || session | 请求上下文 | 用户会话,用于存储请求之间需要&quot;记住&quot;的值的字典 |程序上下文被推送后,就可以使用current_app和g变量.请求上下文被推送后,就可以使用request和session变量.## 2.5.2 请求调度客户端发来请求,要找到处理该请求的视图函数.为了完成和这个任务,Flask会在程序的URL映射中查找请求的URL.URl映射是URL和视图函数之间的对应关系,Flask使用app.route修饰器或者非修饰器形式的app.add_url_rule()生成映射.## 2.5.3 请求钩子在处理请求之前或者之后执行代码,就是请求钩子.请求钩子使用修饰器实现,Flask支持以下四种:- before_first_request:注册一个函数,在处理第一个请求之前运行.- before_request:注册一个函数,在每次请求之前运行.- after_request:注册一个函数,如果没有未处理的异常抛出,在每次请求之后运行.- teardown_request:注册一个函数,及时有未处理的异常抛出,也在每次请求之后运行.在请求钩子与视图函数之间共享数据,一般使用上下文全局变量g.## 2.5.4 响应Response = (内容+状态码+Header字典)其中,状态码:- 400:请求无效- 302:重定向 (Flask提供redirect()辅助函数)- 404:错误 ```abort(404)```abort不会把控制权交给调用它的函数,而是抛出异常把控制权交给Web服务器.# 2.6 Flask扩展之Flask-Script支持命令行选项 from flask.ext.script import Managermanager = Manager(app) #… if name == ‘main‘: manage.run()```在这里,服务器由manager.run()启动,启动后能解析命令行了.","tags":[]},{"title":"Flask复习 一 安装","date":"2017-04-03T15:59:42.000Z","path":"2017/04/03/Flask复习-一-安装/","text":"1.1使用虚拟环境本人使用的是mac,所以 1sudo easy_install virtualenv 安装成功后,需要在项目文件夹中创建python虚拟环境 1virtualenv venv venv即为在项目文件夹中的子文件夹,与虚拟环境相关的文件都保存在这个子文件夹中.然后激活虚拟环境: 1$ source venv/bin/active 回到全局: 1(venv) $ deactivate 1.2 pip安装flaskpip安装即可 1$ pip install flask","tags":[]},{"title":"python不懂就记--标准库argparse","date":"2017-04-03T15:52:47.000Z","path":"2017/04/03/python不懂就记-标准库argparse/","text":"一、简介：argparse是python用于解析命令行参数和选项的标准模块，用于代替已经过时的optparse模块。argparse模块的作用是用于解析命令行参数。例如： 1python parseTest.py input.txt output.txt --user=name --port=8080 二、使用步骤1234import argparseparser = argparse.ArgumentParse() #解析器类是 ArgumentParser 。parser.add_arument()parser.parse_args() 通过调用add_argument()方法向ArgumentParser添加程序的参数信息。通常情况下，这些信息告诉ArgumentParser如何接收命令行上的字符串并将它们转换成对象。这些信息被保存下来并在调用parse_args()时用到。","tags":[]},{"title":"hexo部属个人blog成功","date":"2017-03-05T11:01:04.000Z","path":"2017/03/05/hexo部属个人blog成功/","text":"1.github注册这里我们就不多讲了，可以点击这里，进入官网进行注册。 在仓库名字输入框中输入： ​ 你想要的名字.github.io 2.安装node.js点击进入node.js官网，点击下载安装 3.安装配置hexo 定位博客本地放置的路径 ​ $ cd 文件夹 下载安装hexo ​ $ npm install -g hexo-cli 安装好hexo后。在终端输入： ​ $ hexo ​ 初始化blog // 建立一个博客文件夹，并初始化博客，为文件夹的名称，可以随便起名字 $ hexo init // 进入博客文件夹，为文件夹的名称 $ cd // node.js的命令，根据博客既定的dependencies配置安装所有的依赖包 $ npm install 配置blog 修改网站相关消息 123456title: inerdstacksubtitle: the stack of it nerdsdescription: start from zeroauthor: inerdstacklanguage: zh-CNtimezone: Asia/Shanghai 配置个人域名 1url: http://xxx.com 配置部属 1234deploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master 4.部属以及发表文章### 发表一篇文章 12// 新建一篇文章hexo new &quot;文章标题&quot; 保存后，我们进行本地发布： $ hexo server 打开浏览器， 输入： ​ http://localhsot:4000 部属： ​ $ hexo deploy","tags":[]}]
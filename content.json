[{"title":"celery学习与使用","date":"2018-05-23T10:09:21.000Z","path":"2018/05/23/celery学习与使用/","text":"Celery介绍Celery是一个专注于实时处理和任务调度的分布式任务队列.使用Celery的场景如下: Web应用:异步执行可以减少用户等待操作时间 定时任务 其他可以异步执行的任务:例如发送短信/邮件,推送消息,清理/设置缓存等 Celery架构Celery包含如下组件: Celery Beat:任务调度器,Beat进程会读取配置文件的内容,周期性地将配置中到期需要执行的任务发送给任务队列 Celery Worker:执行任务的消费者,通常会在多台服务器运行多个消费者来提高执行效率 Broker: 消息代理,或者叫消息中间件,接受任务生产者发送过来的任务消息,存进队列再按序分发给任务消费方 Producer: 调用了Celery提供的API,函数或者装饰器而产生任务并交给任务队列处理的都是任务生产者 Result Backend: 任务处理完后保存状态信息和结果,以供查询.Celery默认已经支持Redis,RabbitMQ,MongoDB,Django Orm,SQLAlchemy等方式. Celery初体验方案: 选择RabbitMQ作为消息代理 RabbitMQ的python客户端选择librabbitmq这个C库 选择Msgpack做序列化 选择Redis作为结果存储 简单例子https://github.com/ColaZZ/daily-exercise/tree/master/celery_ex 进阶用法例子中的task.py123@app.task # 普通函数装饰为celery taskdef add(x, y): return x + y 这里的装饰器@app.task实际上是将一个正常的函数修饰成了一个celery task对象,所以我们可以给装饰器加上参数来决定修饰后的task对象的一些属性. 首先,我们可以让被修饰的函数成为task对象的绑定方法,这样就相当于被修饰的函数add成了task的实例方法,可以调用self获取当前task实例的很多状态和属性. 其次,我们也可以自己复写task类然后让这个自定义task修饰函数add,来做一些自定义操作. 1. 根据任务状态执行不同的操作1234567891011# tasks.pyclass MyTask(Task): def on_success(self, retval, task_id, args, kwargs): print &apos;task done: &#123;0&#125;&apos;.format(retval) return super(MyTask, self).on_success(retval, task_id, args, kwargs) def on_failure(self, exc, task_id, args, kwargs, einfo): print &apos;task fail, reason: &#123;0&#125;&apos;.format(exc) return super(MyTask, self).on_failure(exc, task_id, args, kwargs, einfo)@app.task(base=MyTask)def add(x, y): return x + y 2. 绑定任务为实例方法1234567# tasks.pyfrom celery.utils.log import get_task_loggerlogger = get_task_logger(__name__)@app.task(bind=True)def add(self, x, y): logger.info(self.request.__dict__) return x + y 3.任务状态回调实际场景中得知任务状态是很常见的需求，对于 Celery 其内建任务状态有如下几种：| 参数 | 说明 || ————- |:—————:|| PENDING | 任务等待中 || STARTED | 任务已开始 || SUCCESS | 任务执行成功 || FAILURE | 任务执行失败 || RETRY | 任务将被重试 || REVOKED | 任务取消 | 4.定时/周期任务Celery 进行周期任务只需要在配置中配置好周期任务，然后在运行一个周期任务触发器（ beat ）即可： 12345678910# celery_config.pyfrom datetime import timedeltafrom celery.schedules import crontabCELERYBEAT_SCHEDULE = &#123; &apos;ptask&apos;: &#123; &apos;task&apos;: &apos;tasks.period_task&apos;, &apos;schedule&apos;: timedelta(seconds=5), &#125;,&#125;CELERY_RESULT_BACKEND = &apos;redis://localhost:6379/0&apos; 123456# tasks.pyapp = Celery(&apos;tasks&apos;, backend=&apos;redis://localhost:6379/0&apos;, broker=&apos;redis://localhost:6379/0&apos;)app.config_from_object(&apos;celery_config&apos;)@app.task(bind=True)def period_task(self): print &apos;period task done: &#123;0&#125;&apos;.format(self.request.id) 5.调用任务前面讲了调用任务不能直接使用普通的调用方式，而是要用类似 add.delay(2, 2) 的方式调用，而链式任务中又用到了 apply_async 方法进行调用，实际上 delay 只是 apply_async 的快捷方式，二者作用相同，只是 apply_async 可以进行更多的任务属性设置，比如 callbacks/errbacks 正常回调与错误回调、执行超时、重试、重试时间等等","tags":[]},{"title":"如何理解Tornado中的协程模块(gen.coroutine)","date":"2018-05-04T14:43:00.000Z","path":"2018/05/04/如何理解Tornado中的协程模块-gen-coroutine/","text":"tornado.gen 模块是一个基于 python generator 实现的异步编程接口。通过该模块提供的 coroutine （注：这里 coroutine 指的是 ”协程” 概念而不是后面具体实现的 decorator：@gen.decorator），大大简化了在 Tornado 中编写异步代码的工作 —— 支持 “同步方式编写异步代码” ，避免编写烦人的回调函数. @gen.coroutine 实现原理@gen.coroutine 中充分利用了 generator 的特性，下面是其实现代码及分析。123def coroutine(func, replace_callback=True): &quot;&quot;&quot;Decorator for asynchronous generators.&quot;&quot;&quot; return _make_coroutine_wrapper(func, replace_callback=True) coroutine 内部直接委托 _make_coroutine_wrapper 完成具体功能（这段代码中 coroutine 的可选参数 “replace_callback” 是没有使用的），返回一个 Future 实例对象。 _make_coroutine_wrapper(func, replace_callback) 函数作为 @gen.coroutine 和 @gen.engine 内部实现，通过 replace_callback 的值来决定是否对 “callback” 方法参数进行处理。coroutine 的实现中通过 replace_callback=True 调用 _make_coroutine_wrapper 函数，会检查方法参数中是否有 “callback” 参数，如果有的话会将其加入到方法返回值 Future 的完成后回调列表中。如下面代码所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778def _make_coroutine_wrapper(func, replace_callback): @functools.wraps(func) def wrapper(*args, **kwargs): future = TracebackFuture() # 处理 “callback”，忽略或者将其加入到 Future 的完成回调列表中。 if replace_callback and &apos;callback&apos; in kwargs: callback = kwargs.pop(&apos;callback&apos;) IOLoop.current().add_future( future, lambda future: callback(future.result())) try: result = func(*args, **kwargs) except (Return, StopIteration) as e: # 在 python 2 以及 python 3.3 以前，generator 中不能直接通过 # return 返回值：return 被视为 raise StopIteration()， # return &lt;something&gt; 被视为raise StopIteration(&lt;something&gt;)。 # 在 gen 模块中，特别定义了 Return 类型用于返回值：raise gen.Return(something&gt;) result = getattr(e, &apos;value&apos;, None) except Exception: # 发生异常，异常被写入 future（将会被设置为完成状态），结束调用，返回 future future.set_exc_info(sys.exc_info()) return future else: if isinstance(result, types.GeneratorType): # 通过检查 result 是否为 GeneratorType 来选择是否创建 coroutine ，对于 # 同步情况直接 future.set_result(result) 返回，避免创建 coroutine 而 # 造成的性能损失。 # 与 Tornado 4.0 之前的版本比较，这里已经把顶层 ExceptionStackContext # 的构建以及 Runner.run 的功能进行了重构，都迁移到了 Runner 实现中。 # # 通过 next 启动 generator ，启动前记录上下文，启动后对上下文进行一致性检查。 # 若 generator 中有从 &quot;with StackContext&quot; 直接 “yield” 的代码逻辑，将抛 # 出 StackContextInconsistentError 异常。 try: orig_stack_contexts = stack_context._state.contexts yielded = next(result) if stack_context._state.contexts is not orig_stack_contexts: yielded = TracebackFuture() yielded.set_exception( stack_context.StackContextInconsistentError( &apos;stack_context inconsistency (probably caused &apos; &apos;by yield within a &quot;with StackContext&quot; block)&apos;)) except (StopIteration, Return) as e: future.set_result(getattr(e, &apos;value&apos;, None)) except Exception: future.set_exc_info(sys.exc_info()) else: Runner(result, future, yielded) try: return future finally: # Subtle memory optimization: if next() raised an exception, # the future&apos;s exc_info contains a traceback which # includes this stack frame. This creates a cycle, # which will be collected at the next full GC but has # been shown to greatly increase memory usage of # benchmarks (relative to the refcount-based scheme # used in the absence of cycles). We can avoid the # cycle by clearing the local variable after we return it. # # 代码注释中说，generator.next() 抛出异常失败后， future 的 exc_info # 中会包含当前栈帧的引用，栈帧中也有对 future 的引用，这样导致一个环，必须 # 要在下一次 full GC 时才能回收内存。返回 future 后将 future 设置为 None # 可以优化内存。（注：需要 full GC 是与 python 的垃圾回收实现采用引用计数 # 为主，标记-清除和分代机制为辅相关。python 采用引用计数来立刻释放可以释放 # 的内存，然后用标记-清除的方法来清除循环引用的不可达对象。） future = None # 同步情况下，不需要创建 coroutine，直接返回 future。 future.set_result(result) return future return wrapperclass Return(Exception): def __init__(self, value=None): super(Return, self).__init__() self.value = value","tags":[]},{"title":"SSE及Flask-SSE","date":"2018-05-02T16:33:18.000Z","path":"2018/05/03/SSE及Flask-SSE/","text":"#1. SSE介绍SSE(server-sent event服务端推送事件)是为了实时性比较高的需求(例如微博消息推送)而被实现的.在html5标准中,SSE是新增的官方特性,主流浏览器支持教好. 和websocket不同的是，ws是全双工的，本质上是一个额外的tcp连接，而sse是直接建立在当前http连接上的，本质上是保持一个http长连接，但是和comet不同的是：comet是每次服务端返回数据后，连接关闭然后客户端马上再次发起连接。而sse是保持长连接常驻. AJAX 就是客户端自动定时发请求，定时间隔事先指定，不是真正的实时. 而老的http协议是请求-响应式的,实时性较差,实现起来麻烦. #2. Flask-SSEFlask第三方库众多,SSE也不例外. 原理: 1.借用Redis的发布/订阅模式创建一个方法,方法内会调用pubsub.listen监听新的发布数据. 2.使用Flask提供的stream_with_context,不断的从上面的方法中获取数据. 后端包含两个部分,第一部分是用Flask实现${API_URL}/stream这个借口,这是一个长连接,消息就是从这里推送出去的.由于这一部分是阻塞的,我们需要异步的方式往这个阻塞进程里面推送数据,也就是原理第一条,利用Redis的发布/订阅模式发送消息.比如通知调用起来是这样的: 1234from app import app as sse_apiwith sse_api.app_context(): sse.publish(&#123;&apos;count&apos;: count&#125;, type=&apos;notification&apos;)","tags":[]},{"title":"第二章 函数","date":"2017-10-24T15:17:11.000Z","path":"2017/10/24/第二章-函数的副本/","text":"第14条 尽量用异常来表示特殊情况,而不要返回NoneNone会让某些函数误会,产生不可预料的错误避免产生错误的方法: 把返回值拆分成两块(0/1, None/结果) (推荐)根本不返回None,而是把错误抛回上一级,使得调用者必须处理raise ValueError()第15条 了解如何在闭包里使用外围作用域中的变量 闭包:闭包是一种定义在某个作用域中的函数,这种函数引用了那个作用域中里面的变量 python解释器按如下顺序遍历各作用域: 当前函数的作用域 任何外围作用域 包含当前代码的那个模块的作用域(全局作用域) 内置作用域 获取闭包内的数据: python3: nonlocal 声明变量,如果在闭包内给该变量赋值,那么修改的其实是闭包外那个作用域中的变量.nonlocal唯一的限制:不能延伸到模块级别,为了防止它污染全局作用域防止被滥用,nonlocal最好只在简单函数中使用闭包太复杂的时候,改写成辅助类 python2: 将变量变为列表,列表本身是可以修改的,从而修改闭包中变量的值 第16条 考虑用生成器来改写直接返回列表的函数要产生一系列结果时,最简单的做法就是把这些结果append到一份列表里12345678def index_words(text): result = [] if text: result.append(0) for index, letter in enumerate(text): if letter == ' ': result.append(index+1) return result index_words函数有两个问题: 代码写的很拥挤,append太多次没必要 return之前数据都向result中存,如果数据量巨大,可能会导致内存耗尽崩溃 改用生成器: 123456789def index_words_iter(text): if text: yield 0 for index, letter in enumerate(text): if letter == ' ': yield index + 1 result = list(index_words_iter(address)) 生成器注意: 生成器是有状态的,只能使用一次,不可以反复使用","tags":[]},{"title":"第二章 函数","date":"2017-10-24T15:17:11.000Z","path":"2017/10/24/第二章-函数/","text":"第14条 尽量用异常来表示特殊情况,而不要返回NoneNone会让某些函数误会,产生不可预料的错误避免产生错误的方法: 把返回值拆分成两块(0/1, None/结果) (推荐)根本不返回None,而是把错误抛回上一级,使得调用者必须处理raise ValueError()第15条 了解如何在闭包里使用外围作用域中的变量 闭包:闭包是一种定义在某个作用域中的函数,这种函数引用了那个作用域中里面的变量 python解释器按如下顺序遍历各作用域: 当前函数的作用域 任何外围作用域 包含当前代码的那个模块的作用域(全局作用域) 内置作用域 获取闭包内的数据: python3: nonlocal 声明变量,如果在闭包内给该变量赋值,那么修改的其实是闭包外那个作用域中的变量.nonlocal唯一的限制:不能延伸到模块级别,为了防止它污染全局作用域防止被滥用,nonlocal最好只在简单函数中使用闭包太复杂的时候,改写成辅助类 python2: 将变量变为列表,列表本身是可以修改的,从而修改闭包中变量的值 第16条 考虑用生成器来改写直接返回列表的函数要产生一系列结果时,最简单的做法就是把这些结果append到一份列表里12345678def index_words(text): result = [] if text: result.append(0) for index, letter in enumerate(text): if letter == ' ': result.append(index+1) return result index_words函数有两个问题: 代码写的很拥挤,append太多次没必要 return之前数据都向result中存,如果数据量巨大,可能会导致内存耗尽崩溃 改用生成器: 1234567def index_words_iter(text): if text: yield 0 for index, letter in enumerate(text): if letter == &apos; &apos;: yield index + 1 result = list(index_words_iter(address)) 生成器注意: 生成器是有状态的,只能使用一次,不可以反复使用 第17条 在参数上面迭代时,要多加小心 for循环原理: 在执行for x in foo这样的语句时,实际上是调用iter(foo),iter()方法又会调用foo.__iter__这个内置方法,该方法必须返回迭代器对象,迭代器本身又实现了__next__方法,此后for循环反复调用内置的next函数,直到耗尽并产生StopIteration异常.","tags":[]},{"title":"第一章-用Pythonic方式来思考","date":"2017-10-10T16:27:11.000Z","path":"2017/10/11/第一章-用Pythonic方式来思考/","text":"Pythonic是完成Python编程工作的最佳方式 第1条: 确认自己所用的python版本本机为例: 12python --versionPython 2.7.10 12python3 --versionPython 3.6.2 Python2与3选择暂时不做讨论,本人项目已经开始用python3编写. 第2条:遵循PEP8风格指南空白(空格) 使用空格而不是tab 每一层缩进都用4个空格来表示 每行的字符数不应超过79 多行长表达式,除首行外其余各行都应该在通常缩进级别上再加4个空格 函数与类之间应该用两个空行隔开 在同一个类中,各方法之间应该用一个空行隔开 在使用下标来获取列表元素,调用函数或给关键字参数赋值的时候,不要在两旁添加空格 变量赋值的时候,赋值符号的左右两侧应该各自写上一个空格 命名 函数,变量,属性全部小写字母,各单词之间以下划线相连 受保护的实例属性应该以单个下划线开头 私有的实例属性,应该以两个下划线开头 类与异常,应该以每个单词首字母均大写的形式来命名 模块级别的常量,全部大写 类中的实例方法,应该把首个参数命名为self,以表示该对象自身 类方法的首个参数,应该命名为cls,以表示该类自身 表达式和语句 否定词要内联在表达式,不要在表达式外面 不要用len(somelist) == 0 这种方式来判断somelist是否为空,二食应该采用if not somelist这种写法来判断,他会假定:空值将自动评估为False 检测somelist是否为非空时,也应该使用if somelist 这种写法来判断 不要编写单行的if,for,while,except复合语句,而是应该把这些语句分成多行来书写,以示清晰 import语句应该总是放在文件开头 引入模块时,总是应该使用绝对名称 import语句应该按顺序分成三个部分,标准库,第三方,自用.在每一部分中,各import语句应该按模块的字母顺序来排列. 第3条: 了解bytes,str与unicode的区别Python2 str:原始的8位值 decode(str) unicode:Unicode字符串 encode(unicode) str只包含7位ASCII字符,那么unicode和str实例几乎成了同一种类型,Python3中绝对禁止 Python3 bytes:原始的8位值 decode(bytes) str:unicode字符 encode(str) 如果使用open获取了文件句柄,该句柄默认采用UTF-8编码格式来操作文件.原因在于Python3给open函数添加了名为encoding的新参数,并且默认值为UTF-8,这样open(**, w)的时候必须传入Unicode字符的str实例,而不接受bytes.解决方法为使用wb/rb,二进制写入/读取模式,并且可以同时适配Python2和3. 编码与解码的操作一定要在最外围做,并且保证程序的核心部分使用Unicode(Python2中的unicode, Python3中的str) 辅助函数:Python2:12345678def to_unicode(unicode_or_str): def to_str(unicode_or_str): Python3:12345def to_str(bytes_or_str): def to_bytes(bytes_or_str): 第4条 用辅助函数来取代复杂的表达式1. 不要滥用语法特性2. 复杂的表达式放入辅助函数中3. if/else要比or或and这样的Boolean操作符写成的表达式更加清晰(if/else &gt;&gt; or, and)第5条 了解切割序列的办法1. 切割列表时,即便start或end索引越界也不会出现问题,下标访问单个元素时会报错2. 对原列表进行切割之后,会产生一份全新的列表,在切割得到的新列表上进行修改,不会影响原列表3.在赋值时对左侧列表使用切割操作,会把该列表中处在制定范围内的对象替换为新值.位于切片范围外的那些值都保留不变,列表会根据新值的个数相应的扩张或者收缩.12345a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']a[2:7] = [99, 24, 14]print a &gt;&gt;&gt;['a', 'b', 99, 24, 14] 4.起止索引都留空,就会产生一份原列表的拷贝.赋值左侧使用这种切片,系统会把右侧的值复制一份,并用这份拷贝来替换左侧列表的全部内容,而不会分配新列表.第6条 单次切片中不要同时指定start,end和stride1. 使用步进sride时,尽量省略写start和end,同时尽量用正值.2. 先步进式切片,把切割结果赋值给某个变量,再在这个变量上二次切割12b = a[::2]c = b[1:-1] 3. 由于执行时间或者空间很严格,不得不用一次切割的话,选择itertools模块中的islide方法,这个方法不允许start,end,stride为负值第7条 用列表推导来取代map和filter列表推导要比内置的map和filter函数清晰,因为它无需额外编写lambda表达式 字典(dict)和集(set)也支持推导表达式 第8条 不要使用含有两个以上表达式的列表推导代码首先是写给人看的,只是凑巧能被顺利的执行而已 第9条 用生成器表达式来改写数据量较大的列表推导 当输入的数据量较大时,列表推导可能会因为占用太多内存而出问题 把实现列表推导那种写法放在一对圆括号中,就构成了生成器表达式,逐次调用next,即可按照生成器表达式来输出下一个值. 逐次产生输出值,从而避免了内存用量问题. 12345678# 列表推导式value = [len(x) for x in open('/tmp/my_file.txt')]# 生成器表达式it = (len(x) for x in open('tm[/my_file.txt]'))print(it)&gt;&gt;&gt;&lt;generator object &lt;genexpr&gt; at 0x101b81480&gt; # 返回一个生成器 生成器的另一个好处就是可以互相组合 1roots = ((x, x**0.5) for x in it) 要注意的是,由生成器表达式所返回的哪个迭代器是有状态的,用过一段时间后,就不要反复使用了. 第10条 尽量用enumerate取代range enumerate可以把各种迭代器包装为生成器,以便稍后产生输出值. enumerate生成器每次产生一对输出值,前者表示循环下标,后者表示迭代器中获取的下一个序列元素 12345678falvor_list = ['vanilla', 'choc', 'pecan', '士多啤梨']for i, flavor in enumerate(flavor_list): print('%d: %s' % (i+1, flavor))&gt;&gt;&gt;1: vanilla2: choc3: pecan4: 士多啤梨 还可以直接指定enumerate函数开始计数的值,可以使代码更简练 12for i, flavor in enumerate(flavor_list, 1): print('%d: %s' % (i+1, flavor)) 第11条 用zip函数同时遍历两个迭代器 Python3 zip函数可以把两个或者两个以上的迭代器封装为生成器 注意:输入的迭代器长度不同,只要有一个耗尽,zip就不再产生tuple了 不能确定多个迭代器是否等长,可以使用itertools中的zip_longest Python2 zip不是生成器,同等效果可用itertools中的izip 同样不等长可以使用iteritools中的izip_longest 第12条 不要在for和while循环后面写else块 for后面的else块会在for正常执行之后立刻运行 反而for中遇到break提前跳出,会导致程序不执行else块 不要在for/while后面写else块.这样不直观,容易误解. 两种正确写法: 只要发现参数符合条件,就立刻return.遍历一次没有符合条件的,就返回默认值 12345def coprime(a, b): for i in range(2, min(a, b)+1): if a % i == 0 and b % i == 0: return False return True 用变量来记录参数是否符合,一旦符合,立刻break 1234567def coprime2(a, b): is_coprime = True for i in range(2, min(a, b)+1): if a % i == 0 and b % i == 0: is_coprime = False break return False 第13条 合理利用try/except/else/finally结构中的每个代码块 finally块 向上传播,发生异常时执行清理工作,可以使用finally块. finally常见的用途就是确保程序能够可靠地关闭文件句柄 else块 如果try块没有异常,那就执行else块,可以缩减try内容 混合使用 try读取文件并处理其内容,excpet应对异常,else实时更新文件,finally清理句柄","tags":[]},{"title":"Flask复习 十四 应用编程接口","date":"2017-04-03T16:33:42.000Z","path":"2017/04/04/Flask复习-十四-应用编程接口/","text":"Flask是开发REST架构Web服务的理想架构,因为Flask天生轻量. 14.1 REST简介14.1.1 资源就是一切 资源是REST架构方式的核心概念.在REST架构中,资源是程序中你要着重关注的事物.例如,在博客程序中,用户/博客文章和评论都是资源. 每个资源都要使用唯一的URL表示. 某一类资源的集合也要有一个URL. 14.1.2 请求方法 GET POST PUT DELETE DELETE 14.1.3 请求和响应主体REST Web服务常用的两种编码方式是JavaScript对象表示法(JSON)和可扩展标记语言(XML) 14.1.4 版本14.2 使用Flask提供REST Web服务14.2.1 创建API蓝本14.2.2 错误处理为所有客户端生成适当响应的一种方法是,在错误处理程序中根据客户端请求的格式改写响应,这种技术成为内容协商. 14.2.3 使用Flask-HTTPAuth认证用户 REST Web服务的特征之一是无状态,即服务器在两次请求之间不能”记住”客户端的任何消息.客户端必须在发出的请求中包含所有必要信息,因此所有请求都必须包含用户密令. 因为REST构架基于HTTP协议,所以发送密令的最佳方式是使用HTTP认证,基本认证和摘要认证都可以.在HTTP认证中,用户密令包含在请求的Authorization首部中. HTTP认证协议很简单,可以直接实现,不过Flask-HTTPAuth扩展提供了一个便利的包装,可以把协议的细节隐藏在修饰器之中,类似于Flask-login提供的login_required修饰器. 14.2.4 基于令牌的认证 使用基于令牌的认证方案时,客户端要先把登陆密令发送给一个特殊的URL,从而生成认证令牌.一旦客户端获得令牌,就可以用令牌代替登陆密令认证请求. 出于安全考虑,令牌有过期时间.令牌过期后,客户端必须重新发送登陆密令以生成新令牌.令牌落入他人之手所带来的安全隐患受限于令牌的短暂使用期限. generate_auth_toke()方法使用编码后的用户id字段值生成一个签名令牌,还指定了以秒为单位的过期时间. verify_auth_token()是静态方法,因为只有解码令牌后才能知道用户是谁. 为了能够认证包含令牌的请求,我们必须修改Flask-HTTPAuth提供的verify_password回调,除了普通的令牌之外,还要接受令牌. 14.2.5 资源和JSON的序列化转化 把文章转换成JSON格式的序列化字典:app/models def to_json(self): url,author,comments字段要分别返回各自资源的URL,因此他们使用url_for()生成,所调用的路由即将在API蓝本中定义. url_for()方法指定的参数_external=True,这么做是为了生成完整的URL,而不是生成传统WEB程序中经常使用的相对URL. 把用户转换成JSON格式的序列化字典 从JSON格式数据创建一篇博客文章 14.2.6 实现资源点现在我们需要实现用于处理不同资源的路由.GET请求往往是最简单的,因为它只返回信息,无需修改信息. 文章资源GET请求的处理程序:app/api_1_0/posts 用来防止未授权用户创建新博客文章的permission_required修饰器和程序中使用的类似,但会针对API蓝本进行自定义.:app/api_1_1/decorators 博客文章PUT请求的处理程序用来更新现有资源:app/api_1_0/post:edit_posts 14.2.7 分页大型资源集合和Web程序一样,Web服务也可以对集合进行分页. 分页文章资源:api/api_1_0/posts","tags":[]},{"title":"Flask复习 十三 用户评论","date":"2017-04-03T16:33:10.000Z","path":"2017/04/04/Flask复习-十三-用户评论/","text":"13.1 评论在数据库中的表示 评论属于某篇博客文章,因此定义了一个从posts表到commetns表的一对多关系.使用这个关系可以获取膜片特定博客文章的评论列表. comments表还和user表之间有一对多关系.通过这个关系可以获取用户发表的所有评论们还能间接知道用户发表了多少篇评论. Comments模型:app/models.Comment 几乎和Post模型一样,不过多了一个disabled字段.这是个布尔值字段,协管员通过这个字段查禁不当评论. 和博客文章一样,评论也定义了一个事件,在修改body字段时触发,自动把Markdown文本转换成HTML. 转换过程和博客文章一样,不过评论相对较短,而且对Markdown中允许使用的HTML标签要求更严格,要删除与段落相关的标签,只留下格式化字符的标签. 13.2 提交和显示评论 评论输入表单:app/main/forms body:StringField submit() 支持博客文章评论 13.3 管理评论 在导航栏中加入管理评论链接:base.html MODERATE_COMMENTS管理评论权限 管理评论的路由:app/main/views 从数据库中读取一页评论,将其传入模板进行渲染.除了评论列表之外,还把分页对象和当前页数传入了模板. 评论管理页面的模板:moderate.html","tags":[]},{"title":"Flask复习十二 关注者","date":"2017-04-03T16:32:36.000Z","path":"2017/04/04/Flask复习十二-关注者/","text":"12.1 再论数据库关系12.1.1 多对多关系多对多关系解决方法是添加第三张表,这个表称为关联表SQLAlchemy中,多对多关系仍使用定义一对多关系的db.relationship()方法进行定义,但在多对多关系中,必须把secondary参数设为关联表.多对多关系可以在任何一个类中定义,backref参数会处理好关系的另一侧.关联表就是一个简单的表,不是模型(model),SQLAlchemy会自动接管这个表. 12.1.2 自引用关系如果关系中的两侧都在同一个表中,这种关系称为自引用关系.本例的关联表是follows,其中每一行都表示一个用户关注了另一个用户. 12.1.3 高级多对多关系 关注关联表的模型实现:app/models:Follow follower_id followed_id timestamp 使用两个一对多关系实现的多对多关系 User followed followers 为了消除外键间的歧义,定义关系时必须使用可选参数foreign_keys指定的外键.而且db.backref()参数并不是指定这两个关系之间的引用关系,而是返回Follow模型. cascade参数的值是一组由逗号分隔的层叠选项. 关注关系的辅助方法:app/models 程序现在要吃力两个一对多关系,以便实现多对多关系.由于这些操作经常需要重复执行,所以最好在User模型中为所有可能的操作定义辅助方法. 关注def follow(self, user):手动把Follow实例插入关联表 取消关注def unfollow(self, user) 正在关注def is_following(self,user) 被关注def is_followed_by(self, user) 12.2 在资料页中显示关注者 在用户资料页上部添加关注信息:点击”关注”按钮后,执行的是/follow/ “关注”路由和视图函数:app/main/views 这个视图函数先加载请求的用户,确保用户存在且当前登录用户还没有关注这个用户,然后调用User模型中定义的辅助方法follow(),用以联接两个用户. /unfollow/路由的实现方法类似. “关注者”路由和试图函数:/followers/ 这个函数加载并验证请求的用户,然后使用第11章中介绍的技术分页显示该用户的followers关系.由于查询关注者返回的是Follow实例列表,为了渲染方便,我们将其转换成一个新列表,列表中的各元素都包含user和timestamp followers.html 模板使用两列表格实现,左边一列用于显示用户名和头像,右边一列用于显示Flask-Moment时间戳. 12.3 使用数据库联结查询所关注用户的文章left join 12Post.query.join(Follow, Follow.followed_id == Post.author_id)\\ .filter(Follow.follower_id == self.id) 12.4 在首页显示所关注用户的文章 显示所有博客文章或只显示所关注用户的文章 决定显示所有博客文章还是只显示所关注用户文章的选项存储在 cookie 的 show_followed 字段中,如果其值为非空字符串,则表示只显示所关注用户的文章. 查询所有文章还是所关注用户的文章 /all /followed 注册时把自己设为自己的关注者","tags":[]},{"title":"Flask复习 十一 博客文章(二)","date":"2017-04-03T16:31:45.000Z","path":"2017/04/04/Flask复习-十一-博客文章-二/","text":"11.3 分页显示长博客文章列表11.3.1 创建虚拟博客文章数据 使用ForgeryPy导入虚拟数据 dev.txt 列出开发过程中所需的依赖 prod.txt 列出生产中的所需的依赖 因此可以创建一个common.txt文件,在dev.txt和prod.txt中使用-r参数导入. 电子邮箱email=forgery_py.internet.email_address() 11.3.2 在页面中渲染数据 分业显示博客文章列表:app/main/views 渲染的页数从请求的查询字符串(request.args)中获取,如果没有明确指定,则默认渲染第一页. 为了显示某页中的记录,要把all()换成Flask-SQLAlchemy提供的paginate()方法.页数是paginate()方法的第一个参数,也是唯一必须的参数.可选参数per_page用来指定煤业现实的记录数量;如果没有指定,则默认显示20个记录.另一个可选参数为error_out,党旗设为True时(默认值), 如果请求的页数超出了范围,则会返回404错误;如果设为False,页数超出范围时会返回一个空列表. 11.3.3 添加分页导航//////// 11.4 使用markdown和falsk-pagedown支持富文本文章11.4.1 使用Flask-PageDown 初始化Flask-Pagedown:app/init.py 启用Markdown文章表单:用PageDownFieled替换TextAreaField 11.4.2 在服务器上处理富文本 在Post模型中处理Markdown文本:app/models/post 11.5 博客文章的固定链接/post/id为post表中的id 11.6 博客文章编辑器","tags":[]},{"title":"Flask复习 十一 博客文章(一)","date":"2017-04-03T16:30:56.000Z","path":"2017/04/04/Flask复习-十一-博客文章-一/","text":"11.1 提交和显示博客文章 文章模型:app/models id body:博客文章 timestamp:创建时间 author_id:作者id User中添加外键posts 博客文章表单:app/main/forms :PostForm body:博客内容 submit 处理博客文章的首页路由:app/main/views: / 把表单和完整的博客文章列表传给模板.文章列表按照时间戳进行降序排列. 博客文章表单采取惯常处理方式,如果提交的数据能通过验证就创建一个新Post实例. 在发布新文章之前,要检查当前用户是否有写文章的权限. 新文章对象的author属性值为表达式current_user._get_current_object().变量current_user由Flask-Login提供,和所有上下文变量一样,也是通过线程内的代理对象实现.这个对象类似用户对象,但实际上确是一个轻度包装,包含真正的用户对象.数据库需要真正的用户对象,因此要调用_get_current_object()方法. 显示博客文章的首页模板:app/templates/index.html 11.2 在资料页中显示博客文章 获取博客文章的资料页路由:app/main/views posts:user.posts关系获取 显示有博客文章的资料页模板 和index.html一样,user.html模板也要使用一个HTML元素渲染博客文章.维护两个完全相同的HTML片段副本可不是个好主意,遇到这种情况,Jinja2提供的include()指令就非常有用.","tags":[]},{"title":"Flask复习 十 用户资料","date":"2017-04-03T16:30:04.000Z","path":"2017/04/04/Flask复习-十-用户资料/","text":"10.1 资料信息 app/models 用户信息字段 name:真实姓名 location:所在地 about_me:自我介绍 member_since:注册日期 last_seen:最后访问日期 app/models 刷新用户最后访问时间 ping()方法,设置last_seen为datetime.utcnow() app/ayth/views 更新已登录用户的访问时间 before_app_request处理程序会在每次请求前运行 10.2 用户资料页面 资料页面的路由 app/main/views /user/ 10.3 资料编辑器10.3.1 用户级别的资料编辑器 资料编辑表单 app/main/forms : EditProfileForm name location about_me submit 资料编辑路由 app/main/views : enit_profiles() 把初始值赋值给form..data完成的 10.3.2 管理员级别的资料编辑器 管理员使用的资料编辑表单 app/main/forms EditProfileAdminForm email username confirmed role name location about_me submit 管理员的资料编辑路由 app/main/views /edit-profile/ 10.4 用户头像Gravatar提供的用户头像,生成头像的URL时,要计算电子邮件的MD5散列值.生成头像的URL是在http://www.gravatar.com/avatar/或https://secure.gravatar.com/avatar/之后加上这个MD5散列值. 生成Gravatar URL:app/models.User def gravatar() 使用缓存的MD5散列值生成Gravatar URL: app/models 添加字段avatar_hash ​","tags":[]},{"title":"Flask复习 九 用户角色","date":"2017-04-03T16:29:25.000Z","path":"2017/04/04/Flask复习-九-用户角色/","text":"9.1 角色在数据库中的表示 app/models default:只有一个角色的default字段要设为True,其他都设为False.注册时便分配. perimissions字段:整数,表示位标志. 程序的权限 操作 权限 说明 关注用户 0b00000001(0x01) 关注其他用户 在他人的文章中发表评论 0b00000010(0x02) 在他人撰写的文章中发布评论 写文章 0b00000100(0x04) 写原创文章 管理他人发表的评论 0b00001000(0x08) 查处他人发表的不当言论 管理员权限 0b10000000(0x80) 管理网站 class Permission 权限常量 insert_roles() 在数据库中创建角色用户User:FOLLOW | COMMENT | WRITE_ARTICLES0x01 | 0x02 | 0x04 = **0x07** 协管员Moderator:FOLLOW | COMMETN | WRITE_ARTICLES | MODERATE_COMMENTS0x01 | 0x02 | 0x04 | 0x08 = 0x0f 管理员Administrator:0xff如果以后更新了角色列表,就可以执行更新操作了. 9.2 赋予角色app/models: def init(self, **kwargs):User类的构造函数首先调用基类的构造函数,如果创建基类对象后还没定义角色,则根据email地址决定将其设为管理员还是默认角色. 9.3 角色验证 app/models: User:User模型中添加的can()方法在请求和赋予角色这两种权限之间进行位与操作.如果角色中包含请求的所有位权限位,则返回True,表示允许用户执行此项操作.检查管理员权限的功能经常用到,因此使用单独的方法is_administrator()实现. AnonymousUser:can()方法和is_administrator()方法.这个对象继承自Flask-Login中的AnonymousUserMixin类,并将其设为用户未登录时current_user的值.这样程序不用先检查用户是否登陆,就能自由调用current_user.can()和current_user.is_administrator() app/decorators:想让是凸函数只对具有特定权限的用户开放,可以使用自定义的修饰器. permission_required:检查常规权限 admin_required:检查管理员权限不具备条件时,返回403错误码.即HTTP禁止错误 app/main/init 把Permission类加入模板上下文 @main.app_context_processor:上下文处理器","tags":[]},{"title":"Flask复习 八 用户认证(三)","date":"2017-04-03T16:28:42.000Z","path":"2017/04/04/Flask复习-八-用户认证-三/","text":"8.5 注册新用户8.5.1 添加用户注册表单 app/auth/form 用户表单RegistrationForm email username:使用Regexp验证,确保username字段自包含字母,数字,下划线和点号.0,12&apos;Usernames must have only letters, &apos;&apos;numbers, dots or underscores&apos;) password:使用WTForms提供的EqualTo函数判断两次是否一致 password2: submit 查询email是否注册过: validate_email 查询用户名是否注册过: validate_username 使用wtf.quick_form(form)传入前端 最后在login页面加入注册链接 8.5.2 注册新用户 app/auth/view (‘/register’) email username password session.add flash(‘’) 重定向到登录 8.6 确认账户验证电子邮件中的确认地址 8.6.1 使用itsdangerous生成确认令牌TimedJSONWebSignatureSerializer类生成具有过期时间的JSON Web签名 generate_confirmation_token() 方法生成一个令牌，有效期默认为一小时.confirm() 方 法检验令牌，如果检验通过，则把新添加的 confirmed 属性设为 True. 除了检验令牌,confirm()方法还检查令牌中的id是否存储在current_user中的已登录用户匹配.如此一来,即使恶意用户知道如何生成签名令牌,也无法确认别人的账户. 8.6.2 发送确认邮件当前的/register路由把新用户添加到数据库中后,会重定向到/index.在重定向之前,这个路由需要发送确认邮件. app/auth/view /register app/auth/view /confirm/ login_required修饰器确保登陆后才能执行这个视图操作. 由于令牌确认完全在User模型中完成,所以视图函数只需调用confirm()方法即可,然后再根据确认结果显示不同的Flash消息.确认成功后,User模型中confirm属性的值会被修改并添加到会话中,请求处理完后,这个操作被提交到数据库. app/auth/views 在before_app_request处理程序中过滤未确认的账户同时满足以下三个条件,before_app_request处理程序会拦截请求. 用户已登录(current_user.is_authenticated()必须返回True) 用户的账户还未确认 请求的端点(使用reuqest.endpoint获取)不在认证蓝本中.访问认证路由要获取权限,因为这些路由的作用是让用户确认账户或执行其他账户管理操作. 8.7 管理账户8.7.1 修改密码 app/auth/forms ChangePasswordForm old_password:旧密码 password:新密码 password2:重输新密码 submit app/auth/views /change-password 改完密码add一次current_user 最后渲染auth/change_password.html app/templates/auth/change_password.html title col-md-4, wtf.quick_form(form) app/templates/base.html 修改登出部分 8.7.2 重设密码 app/auth/forms PasswordResetRequestForm email submit app/auth/forms PasswordRestForm email password password2 submit validate_email app/auth/views /reset password_reset_request() 渲染auth/reset_password.html app/auth/view /reset/ app/model generate_reset_token reset_password 8.7.3 修改电子邮件地址 app/auth/forms ChangeEmailForm email password submit validate_email app/auth/views /change-email @login_required:登录状态 def change_email_request","tags":[]},{"title":"Flask复习 八 用户认证(一)","date":"2017-04-03T16:27:59.000Z","path":"2017/04/04/Flask复习-八-用户认证-一/","text":"8.1 Flask的认证扩展使用的包如下: Flask-Login:管理已登录用户的用户会话 Werkzeug:计算密码散列值并进行核对 itsdangerous:生成并核对加密安全令牌 8.2 密码安全性若想保证数据库中用户密码的安全,关键在于不能存储密码本身,而要存储密码的散列值.接受密码为输入,使用一种或多种加密算法转换密码,最终得到一个和原始密码没有关系的字符序列. 使用werkzeug实现密码散列Werkzeug中的security模块实现散列值计算.两个函数: generate_password_hash(password, method=pdkfdf2:sha1, salt_length=8) 原始密码作为输入,返回一个字符串形式的散列值,散列值可保存在数据库中.method和salt_length的默认值就能满足大多数需求. check_password_hash(hash,password): 从数据库中取回密码散列值胡密码,True表明密码正确. 8.3 创建认证蓝本auth蓝本保存在同名Python包中,蓝本的包构造文件创建蓝本对象,再从views.py模块中引入路由. 同时,auth蓝本要在create_app()工厂函数中附加到程序上.url_prefix是可选参数.如果使用了这个参数,注册后蓝本中定义的所有路由都会加上指定的前缀.","tags":[]},{"title":"Flask复习 八 用户认证(二)","date":"2017-04-03T16:20:18.000Z","path":"2017/04/04/Flask复习-八-用户认证-二/","text":"8.4 使用Flask-Login认证用户8.4.1 准备用于登陆的用户模型 model:要使用Flask-Login,User Model必须实现几个方法.可以直接写出来,但是Flask-Login提供了一个UserMixin类,包含这几个方法的默认实现,且能满足大多数需求. 工厂函数初始化: LoginManager对象的session_protection属性可以设为None,’basic’,’strong’,已提供不同的安全等级防止用户会话遭篡改.设为’strong’时,Flask-Login会记录客户端IP的地址和浏览器的用户代理信息,如果发现异动就登出用户. login_view属性设置登录页面的端点. 最后实现一个回调函数,使用指定的标识符加载用户. 该回调函数接收以Unicode字符串形式表示的用户标识符.如果能找到用户,这个函数必须返回用户对象;否则应该返回None. 8.4.2 保护路由为了保护路由只让认证用户访问,Flask-Login提供了一个login_required修饰器. 8.4.3 添加登录表单给用户一个登录表单,一个用于输入电子邮件地址的文本字段,一个密码字段,一个”记住我”复选框和提交按钮. app/auth/forms email:验证函数Email() password:PasswordField表示type=’password’的元素 remember_me:BooleanField表示复选框 app/templates/base.html登录条 is_authenticated():判断用户是否登录,登录返回True,否则False 逻辑为如果用户在登录状态,则显示登出.否则显示登录. 8.4.4 登入用户 app/auth/views 这个视图函数创建了一个LoginForm.GET时视图函数直接渲染模板,即显示表单.POST时,Flask-WTF中的validate_on_submit()函数会验证表单数据,然后尝试登入用户. 首先使用填写的email从数据库中查询用户,然后verify_password(),第三步调用login_user()函数,在用户会话中把用户标记为已登录. 记住我选项:False的话,关闭浏览器后用户会话过期.True的话会在用户浏览器中写入一个长期有效的 cookie，使用这个 cookie 可以复现用户会话. 目标URL有两种可能:用户访问未授权的URL时会显示登录表单,Flask-Login会把原地址保存在查询字符串next中,从request.args中读取.如果没有next,则重定向到首页. 密码或email不正确,显示flash消息. 8.4.5 登出用户‘/logout’:使用logout_user()函数,实现删除并删除重设用户会话.随后显示一个Flash消息,再重定向到首页. 8.4.6 测试登录","tags":[]},{"title":"Flask复习 七 大型程序的结构(二)","date":"2017-04-03T16:19:31.000Z","path":"2017/04/04/Flask复习-七-大型程序的结构-二/","text":"7.4 启动脚本manage.pyw文件 初始化Flask-Script,Flask-Migrate和未Python Shell定义的上下文. 7.5 需求文件requirements.txt文件$ pip freeze >requirements.txt ```该命令自动生成这个文件123456789# 7.6 单元测试使用python标准库中的unittest编写(assertFasle和assertTrue)setUp() 方法尝试创建一个测试环境，类似于运行中的程序。首先，使用测试配置创建程 序，然后激活上下文。这一步的作用是确保能在测试中使用 current_app，像普通请求一 样。然后创建一个全新的数据库，以备不时之需。数据库和程序上下文在 tearDown() 方法 中删除。# 7.7 创建数据库数据库创建或者升级 (venv) $ python manage.py db upgrade```","tags":[]},{"title":"Flask复习 七 大型程序的结构(一)","date":"2017-04-03T16:19:03.000Z","path":"2017/04/04/Flask复习-七-大型程序的结构-一/","text":"7.1 项目结构1234567891011121314151617181920|-flasky |-app/ # Flask主程序 (7.3) |-templates/ |-static/ |-main/ |-__init__.py |-errors.py |-forms.py |-views.py |-__init__.py |-email.py |-models.py |-migrations/ # 数据库迁移脚本 |-tests/ # 单元测试 |-__init__.py |-test*.py |-venv/ # 虚拟环境 |-requirements.txt # 列出所有依赖包 |-config.py # 存储配置 (7.2) |-manage.py # 用于启动程序以及其他程序的任务 7.2 配置选项config.py文件 通过访问os.envirom字典可以访问环境变量 开发(dev), 测试(test), 生产环境(product)要使用不同的数据库,这样不会彼此影响.在config.py中,使用三个子类,SQLALCHEMY_DATABASE_URI变量都被指向了不同的值.这样程序就可以在不同的配置环境中运行,每个环境都使用不同的数据库. 7.3 程序包app文件夹 当然,如果你有需求,也可以使用其他名字 7.3.1 使用程序工厂函数app/init.py文件 单个文件开发程序很方便,但是有个很大的问题.程序在全局域中创建,所以无法动态修改配置.解决方法:延迟创建程序实例,把创建过程移到可显式调用的工厂函数中. 7.3.2 在蓝本中实现程序功能app/main/init.py文件 如果在app/init.py中create_app()之后再调用app.route修饰器显然太晚了.app.errorhandler也面临同样的问题. 幸好Flask使用蓝本提供了解决方法.蓝本和程序类似,也可以定义路由.不同的是,在蓝本中定义的路由处于休眠状态,直到蓝本注册到程序上之后,路由才真正的成为程序的一部分. 通过实例化一个Blueprint类对象可以创建蓝本.这个构造函数有两个必须制定的参数:蓝本的名字(main)和蓝本所在的包或模块(大多数情况下使用name变量即可). app/main/errors.py:蓝本中的错误处理在蓝本中编写错误处理程序稍有不同，如果使用 errorhandler 修饰器，那么只有蓝本中的错误才能触发处理程序。要想注册程序全局的错误处理程序，必须使用 app_errorhandler。 app/main/view.py:蓝本中定义的程序路由在蓝本中编写视图函数主要有两点不同:第一,和errorhandler一样,route路由修饰器由蓝本提供第二,url_for()函数的用法不同. url_for()函数的第一个参数是路由的端点名,在程序的路由中,默认为视图函数的名字. 在蓝本中,Flask会为蓝本中的全部端点加上一个命名空间,这样就可以在不同的蓝本中使用相同的端点名定义视图函数,而不会产生冲突.命名空间就是蓝本的名字(Blueprint构造函数的第一个参数),所以index()注册的端点名是main.index,其URL使用url_for(‘main.index’)获取. url_for()函数还支持一种简写的端点形式,在蓝本中可以省略蓝本名,例如url_for(&#39;.index&#39;),但是跨蓝本的重定向必须使用带有命名空间的端点名.","tags":[]},{"title":"Flask复习 六 电子邮件","date":"2017-04-03T16:18:28.000Z","path":"2017/04/04/Flask复习-六-电子邮件/","text":"使用Flask-Mail提供电子邮件支持Flask-Mail 连接到简单邮件传输协议（ Simple Mail Transfer Protocol， SMTP）服务器，并把邮件交给这个服务器发送。 如果不进行配置，Flask-Mail会连接localhost 上的端口 25，无需验证即可发送电子邮件。 Flask-Mail SMTP服务器的配置 配置 默认值 说明 MAIL_SERVER localhost 电子邮件服务器的主机名或IP地址 MAIL_PORT 25 电子邮件服务器的端口 MAIL_USE_TLS False 启用传输层安全协议(TLS) MAIL_USE_SSL False 启用安全套接层协议(SSL) MAIL_USERNAME None 邮件账户的用户名 MAIL_PASSWORD None 邮件账户的密码 示例:使用Gmail发送电子邮件1234567import os# ...app.config[&apos;MAIL_SERVER&apos;] = &apos;smtp.googlemail.com&apos;app.config[&apos;MAIL_PORT&apos;] = 587app.config[&apos;MAIL_USE_TLS&apos;] = Trueapp.config[&apos;MAIL_USERNAME&apos;] = os.environ.get(&apos;MAIL_USERNAME&apos;)app.config[&apos;MAIL_PASSWORD&apos;] = os.environ.get(&apos;MAIL_PASSWORD&apos;) 保存电子邮件服务器用户名和密码的两个环境变量要在环境中定义:12(venv) $ export MAIL_USERNAME=&lt;Gmail username&gt;(venv) $ export MAIL_PASSWORD=&lt;Gmail password&gt; 在程序中集成发送电子邮件功能异步发送电子邮件","tags":[]},{"title":"Flask复习 五 数据库(三)","date":"2017-04-03T16:17:25.000Z","path":"2017/04/04/Flask复习-五-数据库-三/","text":"5.9 在视图函数中操作数据库5.10 集成python shell注册一个make_context回调函数,把对象添加到导入列表中1234from flask.ext.script import Shelldef make_shell_context(): return dict(app=app, db=db, User=User, Role=Role)manager.add_command(&quot;shell&quot;,Shell(make_context=make_shell_context)) 5.11 使用Flask-Migrate实现数据库迁移Flask-Migrate扩展对Alembic做了轻量级包装,病集成到Flask-Script中,所有操作都通过Flask-Script完成. 5.11.1 创建迁移仓库首先,配置Flask-Migrate,把Flask-Migrate包装进Flask-Script语句中.1234from flask.ext.migrate import Migrate, MigrateCommand# ...migrate = Migrate(app, db)manager.add_command(&apos;db&apos;, MigrateCommand) 然后,使用init子命令创建迁移仓库:1(venv) $ python hello.py db init 这个命令会创建migrations文件夹,所有迁移脚本都存放其中. 5.11.2 创建迁移脚本在Alembic中,数据库迁移用迁移脚本表示.脚本中有两个函数,分别是upgrade()和downgrade().upgrade()函数把迁移中的改动应用到数据库中,downgrade()函数则将改动删除.migrade子命令用来自动创建迁移脚本:1(venv) $ python hello.py db migrate -m &quot;initial migration&quot; 5.11.3 更新数据库检查并修正好脚本之后,我们可以使用db upgrade命令把迁移应用到数据库中:1(venv) $ python hello.py db upgrade 对第一个迁移来说，其作用和调用 db.create_all() 方法一样。但在后续的迁移中，upgrade 命令能把改动应用到数据库中，且不影响其中保存的数据。","tags":[]},{"title":"Flask复习 五 数据库(二)","date":"2017-04-03T16:14:43.000Z","path":"2017/04/04/Flask复习-五-数据库-二/","text":"5.8 数据库操作5.8.1 创建表db.create_all()函数创建表123(venv) $ python hello.py shell&gt;&gt;&gt; from hello import db&gt;&gt;&gt; db.create_all() 删除旧表使用函数123456&lt;!-- more --&gt;## 5.8.2 插入行在Flask-SQLAlchemy中,会话由db.session表示.准备把对象写入数据库之前,先要将其添加到会话中: db.session.add(admin_role)db.session.add(mod_role)db.session.add(user_role)db.session.add(user_john)db.session.add(user_susan)db.session.add(user_david)1或者简写成: db.session.add_all([admin_role, mod_role, user_role,… user_john, user_susan, user_david])1然后调用commit()方法提交会话: db.session.commit()12345## 5.8.3 修改行调用add()方法也能更新模型## 5.8.4 删除行 db.session.delete(mod_role)db.session.commit()1234## 5.8.5 查询行Flask-SQLAlchemy为每个模型类都提供了query对象.所有记录: Role.query.all()User.query.all()12filter()过滤器可以配置query对象进行精确地数据库查询.若要查看SQLAlchemy为查询生成的原生SQL查询语句,只需把query对象转换成字符串: str(User.query.filter_by(role=user_role)) ‘SELECT users.id AS users_id, users.username AS users_username,users.role_id AS users_role_id FROM users WHERE :param_1 = users.role_id’``` 常用的SQLAlchemy查询过滤器 过滤器 说明 filter() 把过滤器添加到原查询上，返回一个新查询 filter_by() 把等值过滤器添加到原查询上，返回一个新查询 limit() 使用指定的值限制原查询返回的结果数量，返回一个新查询 offset() 偏移原查询返回的结果，返回一个新查询 order_by() 根据指定条件对原查询结果进行排序，返回一个新查询 group_by() 根据指定条件对原查询结果进行排序,返回一个新查询 常用的SQLAlchemy查询执行函数 方法 说明 all() 以列表形式返回查询的所有结果 first() 返回查询的第一个结果，如果没有结果，则返回 None first_or_404() 返回查询的第一个结果，如果没有结果，则终止请求,返回404错误响应 get() 返回指定主键对应的行，如果没有对应的行，则返回 None get_or_404() 返回指定主键对应的行，如果没有对应的行，则终止请求,返回404错误响应 count() 返回查询结果的数量 paginate() 返回一个Paginate对象,它包含指定范围内的结果","tags":[]},{"title":"Flask复习 五 数据库","date":"2017-04-03T16:13:57.000Z","path":"2017/04/04/Flask复习-五-数据库/","text":"SQL数据库:关系型数据库NoSQL数据库:文档数据库和键值对数据库 5.1 SQL数据库 5.2 NoSQL数据库 5.3 使用SQL还是NoSQLSQL 数据库擅于用高效且紧凑的形式存储结构化数据.这种数据库需要花费大量精力保证数据的一致性.NoSQL数据库放宽了对这种一致性的要求,从而获得性能上的优势. 5.4 Python数据库框架本项目选用Flask-SQLAlchemy 5.5 使用Flask-SQLAlchemy管理数据库数据库使用URL指定.程序使用的数据库URL必须保存到Flask配置对象的SQLALCHEMY_DATABASE_URI键中.配置对象中还有一个很有用的选项,即SQLALCHEMY_COMMIT_ON_TEARDOWN键,将其设为True时,每次请求结束后都会自动提交数据库中的变动. 配置SQLite数据库示例12345678910from flask.ext.sqlalchemy import SQLAlchemybasedir = os.path.abspath(os.path.dirname(__file__))app = Flask(__name__)app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] =\\ &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)app.config[&apos;SQLALCHEMY_COMMIT_ON_TEARDOWN&apos;] = Truedb = SQLAlchemy(app) db对象时SQLAlchemy类的实例,表示程序使用的数据库,同时还获得了Flask-SQLAlchemy提供的所有功能. 5.6 定义模型定义Role和User 123456789101112131415class Role(db.Model): __tablename__ = &apos;roles&apos; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) def __repr__(self): return &apos;&lt;Role %r&gt;&apos; % self.name class User(db.Model): __table__=&apos;roles&apos; id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) def __repr__(self): return &apos;&lt;User %r&gt;&apos; % self.username 定义数据库中使用的表名.1234567891011121314151617181920212223242526272829303132333435db.Column类构造的第一个参数是数据库列和模型属性的类型.常用的SQLAlchemy列类型| 类型名 | python类型 | 说明 || ------------ | ------------------ | ----------------------------- || Integer | int | 普通整数,一般是32位 || SmallInteger | int | 取值范围小的整数,一般是16位 || BigInteger | int或long | 不限精度的整数 || Float | float | 浮点数 || Numeric | decimal.Decimal | 定点数 || String | str | 变长字符串 || Text | str | 变长字符串,对较长或不限长度的字符串做了优化 || Unicode | unicode | 变长Unicode字符串 || UnicodeText | unicode | 变长Unicode字符串,对较长或不限长度的字符串做了优化 || Boolean | bool | 布尔值 || Date | datetime.date | 日期 || Time | datetime.date | 时间 || DateTime | datetime.datetime | 日期和时间 || Interval | datetime.timedelta | 时间间隔 || Enum | str | 一组字符串 || PickleType | 任何Python对象 | 自动使用Pickle序列化 || LargeBinary | str | 二进制文件 |最常使用的SQLAlchemy列选项| 选项名 | 说明 || ----------- | ------------------------------------- || primary_key | 如果设为True,这列就是表的主键 || unique | 如果设为True,这列不允许出现重复的值 || index | 如果设为True,为这列创建索引,提升查询效率 || nullable | 如果设为True,这列允许使用空值,如果设为False,这列不允许使用空值 || default | 为这列定义默认值 |# 5.7 关系 class Role(db.Model): # ... users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;) class User(db.Model): # ... role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;)) ```db.relationship() 的第一个参数表明这个关系的另一端是哪个模型.如果模型尚未定义,可使用字符串形式指定. db.relationship() 中的backref参数向User模型中添加一个role 的属性,从而定义反向关系.这一属性克替代role_id访问Role模型,此时获取的是模型对象,而不是外键的值. 常用的SQLAlchemy关系选项 选项名 说明 backref 在关系的另一个模型中添加反向引用 primaryjoin 明确指定两个模型之间使用的联结条件.只在模棱两可的关系中需要指定 lazy 指定如何加载相关记录。可选值有 select（首次访问时按需加载）、 immediate（源对象加 载后就加载）、 joined（加载记录，但使用联结）、 subquery（立即加载，但使用子查询），noload（永不加载）和 dynamic（不加载记录，但提供加载记录的查询）uselist | 如果设为False,不适用列表,而使用标量值order_by | 指定关系中记录的排序方式secondary | 指定多对多关系中关系表的名字secondaryjoin | SQLAlchemy无法自行决定时,指定多对多关系中的二级联结条件","tags":[]},{"title":"Flask复习 三 模板(三)","date":"2017-04-03T16:11:32.000Z","path":"2017/04/04/Flask复习-四-Web表单/","text":"使用Flask-WTF库实现Web表单 4.1 跨站请求伪造保护Flask-WTF保护方法:设置秘钥 12app = Flask(__name__)app.config[&apos;SECRET_KEY&apos;] = &apos;hard to guess string&apos; 4.2 表单类1234567from falsk.ext.wtf import Formfrom wtfforms import StringField, SubmitFieldfrom wtfforms.validators import Requiredclass NameForm(Form): name = StringField(&apos;what is your name?&apos;, validators=[Required()]) submit = SubmitField(&apos;Submit&apos;) StringField 类表示属性为 type=”text” 的 元素。SubmitField 类表示属性为 type=”submit” 的 元素。字段构造函数的第一个参数是把表单渲染成 HTML 时使用的标号。StringField 构造函数中的可选参数 validators 指定一个由验证函数组成的列表，在接受 用户提交的数据之前验证数据。验证函数 Required() 确保提交的字段不为空。 WTForms支持的HTML标准字段 字段类型 说明 StringField 文本字段 TextAreaField 多行文本字段 PasswordField 密码文本字段 HiddenField 隐藏文本字段 DateField 文本字段,值为datetime.date格式 DateTimeField 文本字段,值为datetime.datime格式 IntegerField 文本字段,值为整数 DecimalField 文本字段,值为decimal.Decimal FloatField 文本字段，值为浮点数 BooleanField 复选框,值为True和False RadioField 一组单选框 SelectField 下拉列表 SelectMultipleField 下拉列表,可以选择多个值 FileField 文件上传字段 SubmitField 表单提交按钮 FormField 把表单作为字段嵌入另一个表单 FieldList 一组制定类型的字段 WTForms验证函数 验证函数 说明 Email 验证电子邮件地址 EqualTo 比较两个字段的值;常用于要求输入两次密码进行确认的情况 IPAddress 验证 IPv4 网络地址 Length 验证输入字符串的长度 NumberRange Optional 验证输入的值在数字范围内 Optional 无输入值时跳过其他验证函数 Required 确保字段中有数据 Regexp 使用正则表达式验证输入值 URL 验证 URL AnyOf 确保输入值在可选值列表中 NoneOf 确保输入值不在可选值列表中 4.3 把表单渲染成HTMLFlask-Bootstrap 提供了一个非常高端的辅助函数，可以使用Bootstrap中预先定样式渲染整个 Flask-WTF 表单，而这些操作 只需一次调用即可完成。12&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125; &#123;&#123; wtf.quick_form(form) &#125;&#125; wtf.quick_form()函数的参数为Flask-WTF表单对象,使用Bootstrap的默认样式传入的表单. 4.4 在视图函数中处理表单表单大多作为POST请求进行处理(GET会在URL中暴露数据)12345678@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]) def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = &apos;&apos; return render_template(&apos;index.html&apos;, form=form, name=name) 局部变量 name 用来存放表单中输入的有效名字，如果没有输入，其值为 None。如上述代 码所示，在视图函数中创建一个 NameForm 类实例用于表示表单。提交表单后，如果数据能 被所有验证函数接受，那么 validate_on_submit() 方法的返回值为 True，否则返回 False。 这个函数的返回值决定是重新渲染表单还是处理表单提交的数据。 用户第一次访问程序时，服务器会收到一个没有表单数据的 GET 请求，所以 validateon submit() 将返回 False。if 语句的内容将被跳过，通过渲染模板处理请求，并传入表单对 象和值为 None 的 name 变量作为参数。用户会看到浏览器中显示了一个表单。 用户提交表单后，服务器收到一个包含数据的 POST 请求。validate_on_submit() 会调用 name 字段上附属的 Required() 验证函数。如果名字不为空，就能通过验证，validateon submit() 返回 True。现在，用户输入的名字可通过字段的 data 属性获取。在 if 语句中， 把名字赋值给局部变量 name，然后再把 data 属性设为空字符串，从而清空表单字段。最 后一行调用 render_template() 函数渲染模板，但这一次参数 name 的值为表单中输入的名 字，因此会显示一个针对该用户的欢迎消息。 4.5 重定向和用户会话用户输入名字后提交表单，然后点击浏览器的刷 新按钮，会看到一个莫名其妙的警告，要求在再次提交表单之前进行确认。之所以出现这 种情况，是因为刷新页面时浏览器会重新发送之前已经发送过的最后一个请求。如果这个 请求是一个包含表单数据的 POST 请求，刷新页面后会再次提交表单。大多数情况下，这并 不是理想的处理方式。 很多用户都不理解浏览器发出的这个警告。基于这个原因，最好别让 Web 程序把 POST 请 求作为浏览器发送的最后一个请求。 解决方法是,使用重定向作为POST请求的响应,而不是使用常规响应.浏览器收到 这种响应时，会向重定向的 URL 发起 GET 请求，显示页面的内容. 这个技巧称为Post/重定向/Get模式.12345678from flask import Flask, render_template, session, redirect, url_for@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data return redirect(url_for(&apos;index&apos;)) return render_template(&apos;index.html&apos;, form=form,name=session.get(&apos;name&apos;)) 4.6 Flash消息请求完成后,需要让用户知道确认消息,警告或者错误提醒.这个时候需要flash()函数,也是Flask的核心特性.1234567891011from flask import Flask, render_template, session, redirect, url_for, flash@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get(&apos;name&apos;) if old_name is not None and old_name != form.name.data: flash(&apos;Looks like you have changed your name!&apos;) session[&apos;name&apos;] = form.name.data return redirect(url_for(&apos;index&apos;)) return render_template(&apos;index.html&apos;, form = form, name = session.get(&apos;name&apos;)) 模板中渲染flash()消息,需要Flask开放的get_flashed_messages()函数.1234#...&#123;% for message in get_flashed_messages() %&#125;#...&#123;&#123; message &#125;&#125; 在模板中使用循环是因为在之前的请求循环中每次调用 flash() 函数时都会生成一个消息， 所以可能有多个消息在排队等待显示。get_flashed_messages() 函数获取的消息在下次调 用时不会再次返回，因此 Flash 消息只显示一次，然后就消失了。","tags":[]},{"title":"Flask复习 三 模板(二)","date":"2017-04-03T16:11:08.000Z","path":"2017/04/04/Flask复习-三-模板-二/","text":"3.2 使用Flask-Bootstrap集成 Bootstrap安装:$ pip install flask-bootstrap ```123初始化:&lt;!-- more --&gt; from flask.ext.bootstrap import Bootstrap #…bootstrap = Bootstrap(app)12345678910111213141516171819202122| 块名 | 说明 || ------------ | ----------------- || doc | 整个HTML文档 || html_attribs | &lt;html&gt;标签的属性 || html | &lt;html&gt;标签中的内容 || head | &lt;head&gt;标签中的内容 || title | &lt;title&gt;标签中的内容 || metas | 一组&lt;meta&gt;标签 || styles | 层叠样式表定义 || body_attribs | &lt;body&gt;标签的属性 || body | &lt;body&gt;标签中的内容 || navbar | 用户定义的导航条 || content | 用户定义的页面内容 || scripts | 文档底部的Javascript声明 |上表中很多块欧式Flask-Bootstrap自用的,如果直接重定义可能会导致一些问题.例如，Bootstrap所需的文件在styles和scripts块中声明。如果程序需要向已经有内容的块中添加新内容， 必须使用 Jinja2 提供的 super() 函数。# 3.3 自定义错误页面自定义错误页面的路由和响应函数:1. 404,客户端请求未知页面或路由时显示.2. 500,有未处理的异常时显示. @app.errorhandler(404):def page_not_found(e): return render_template(‘404.html’), 404 @app.errorhandler(500);def internal_server_error(e): return render_template(‘500.html’), 500123456错误页面的模板由Jinja2的模板继承机制实现.# 3.4 链接```url_for()``` 辅助函数,她可以使用程序URL映射中保存的信息生成URL.以下都是合法调用: url_for(‘index’) # 得到的结果是/url_for(‘index’, _external=True) # 得到的结果是绝对地址,http://localhost:5000/url_for(‘user’, name=’john’, _external=True) #返回结果是http://localhsot:5000/user/johnurl_for(‘index’, page=2) #得到的结果是/?page=2``` 3.5 静态文件static文件夹下面 3.6使用Flask-Moment本地化日期和时间要想在服务器上只是用UTC时间,一个优雅的解决方案是,把时间单位发送给Web浏览器,转换成当地时间,然后渲染.本项目中使用第三方库Flask-Moment,把moment.js集成到Jinja2模板中.","tags":[]},{"title":"Flask复习 二 程序基本结构","date":"2017-04-03T16:03:38.000Z","path":"2017/04/04/Flask复习-二-程序基本结构/","text":"2.1 初始化Web服务器使用一种名为Web服务器网关接口的协议,把接受自客户端的所有请求都转交给这个对象处理. 12from flask import Flaskapp = Flask(__name__) name的值app就是程序主模块或包的名字. 2.2 路由和视图函数app.route修饰器定义路由 123@app.route(&apos;/&apos;)def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos; index为视图函数,在浏览器中访问默认网址后,会触发服务器执行index()函数.这个函数的返回值成为响应,是客户端接收到的内容.动态地址route修饰器同样支持. 123@app.route(&apos;/user/&lt;name&gt;&apos;)def user(name): return &apos;&lt;h1&gt;Hello, %s!&lt;/h1&gt;&apos; % name 尖括号中123# 2.3 启动服务器```run``` 方法启动Flask集成的开发Web环境: if name == ‘main‘ app.run(debug=True)1234567891011121314151617181920212223242526272829303132333435363738服务器启动后,胡进入轮询,等待并处理请求.轮询会一直运行,知道程序停止,比如ctrl-c.# 2.5 请求-响应循环## 2.5.1 程序和请求上下文上下文把某些对象变为全局可访问.有了上下文,可以避免大量可有可无的参数把视图函数搞乱.Flask使用上下文让特定的变量在一个线程中全局可访问,并且不会干扰其他线程.| 变量名 | 上下文 | 说明 || ----------- | ----- | --------------------------- || current_app | 程序上下文 | 当前激活程序的程序实例 || g | 程序上下文 | 处理请求时用作临时存储的对象.每次请求都会重设这个变量 || request | 请求上下文 | 请求对象,封装了客户端发出的HTTP中的请求 || session | 请求上下文 | 用户会话,用于存储请求之间需要&quot;记住&quot;的值的字典 |程序上下文被推送后,就可以使用current_app和g变量.请求上下文被推送后,就可以使用request和session变量.## 2.5.2 请求调度客户端发来请求,要找到处理该请求的视图函数.为了完成和这个任务,Flask会在程序的URL映射中查找请求的URL.URl映射是URL和视图函数之间的对应关系,Flask使用app.route修饰器或者非修饰器形式的app.add_url_rule()生成映射.## 2.5.3 请求钩子在处理请求之前或者之后执行代码,就是请求钩子.请求钩子使用修饰器实现,Flask支持以下四种:- before_first_request:注册一个函数,在处理第一个请求之前运行.- before_request:注册一个函数,在每次请求之前运行.- after_request:注册一个函数,如果没有未处理的异常抛出,在每次请求之后运行.- teardown_request:注册一个函数,及时有未处理的异常抛出,也在每次请求之后运行.在请求钩子与视图函数之间共享数据,一般使用上下文全局变量g.## 2.5.4 响应Response = (内容+状态码+Header字典)其中,状态码:- 400:请求无效- 302:重定向 (Flask提供redirect()辅助函数)- 404:错误 ```abort(404)```abort不会把控制权交给调用它的函数,而是抛出异常把控制权交给Web服务器.# 2.6 Flask扩展之Flask-Script支持命令行选项 from flask.ext.script import Managermanager = Manager(app) #… if name == ‘main‘: manage.run()```在这里,服务器由manager.run()启动,启动后能解析命令行了.","tags":[]},{"title":"Flask复习 一 安装","date":"2017-04-03T15:59:42.000Z","path":"2017/04/03/Flask复习-一-安装/","text":"1.1使用虚拟环境本人使用的是mac,所以 1sudo easy_install virtualenv 安装成功后,需要在项目文件夹中创建python虚拟环境 1virtualenv venv venv即为在项目文件夹中的子文件夹,与虚拟环境相关的文件都保存在这个子文件夹中.然后激活虚拟环境: 1$ source venv/bin/active 回到全局: 1(venv) $ deactivate 1.2 pip安装flaskpip安装即可 1$ pip install flask","tags":[]},{"title":"python不懂就记--标准库argparse","date":"2017-04-03T15:52:47.000Z","path":"2017/04/03/python不懂就记-标准库argparse/","text":"一、简介：argparse是python用于解析命令行参数和选项的标准模块，用于代替已经过时的optparse模块。argparse模块的作用是用于解析命令行参数。例如： 1python parseTest.py input.txt output.txt --user=name --port=8080 二、使用步骤1234import argparseparser = argparse.ArgumentParse() #解析器类是 ArgumentParser 。parser.add_arument()parser.parse_args() 通过调用add_argument()方法向ArgumentParser添加程序的参数信息。通常情况下，这些信息告诉ArgumentParser如何接收命令行上的字符串并将它们转换成对象。这些信息被保存下来并在调用parse_args()时用到。","tags":[]},{"title":"hexo部属个人blog成功","date":"2017-03-05T11:01:04.000Z","path":"2017/03/05/hexo部属个人blog成功/","text":"1.github注册这里我们就不多讲了，可以点击这里，进入官网进行注册。 在仓库名字输入框中输入： ​ 你想要的名字.github.io 2.安装node.js点击进入node.js官网，点击下载安装 3.安装配置hexo 定位博客本地放置的路径 ​ $ cd 文件夹 下载安装hexo ​ $ npm install -g hexo-cli 安装好hexo后。在终端输入： ​ $ hexo ​ 初始化blog // 建立一个博客文件夹，并初始化博客，为文件夹的名称，可以随便起名字 $ hexo init // 进入博客文件夹，为文件夹的名称 $ cd // node.js的命令，根据博客既定的dependencies配置安装所有的依赖包 $ npm install 配置blog 修改网站相关消息 123456title: inerdstacksubtitle: the stack of it nerdsdescription: start from zeroauthor: inerdstacklanguage: zh-CNtimezone: Asia/Shanghai 配置个人域名 1url: http://xxx.com 配置部属 1234deploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master 4.部属以及发表文章### 发表一篇文章 12// 新建一篇文章hexo new &quot;文章标题&quot; 保存后，我们进行本地发布： $ hexo server 打开浏览器， 输入： ​ http://localhsot:4000 部属： ​ hexo generate 来生成静态内容 ​ $ hexo deploy","tags":[]}]